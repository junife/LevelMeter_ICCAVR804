Interrupt Vectors
00000 940C 018B JMP	__start|__text_start
...
00010 940C 0D1E JMP	_timer1_ovf_isr     
00012 940C 0CA0 JMP	_timer0_ovf_isr     
Program Code (text area)
_Button_Scan:
  key                  --> R10
  i                    --> R20
    001AE 940E 1231 CALL	push_xgsetF00C
FILE: C:\Users\junife\Documents\GitHub\LevelMeter_ICCAVR804\ICCAVR\src\button.c
(0001) /*****************************************************************
(0002) ******************************************************************/
(0003) #include <iom16v.h>
(0004) #include <macros.h>
(0005) #include "button.h"
(0006) #include "led.h"
(0007) 
(0008) BUTTON_STRUCT_T  button[2] = {BUTTON_STATE_UNDEFINED, BUTTON_STATE_UNDEFINED, 0, 0, FALSE, FALSE, FALSE};
(0009) 
(0010) void Button_Scan(void)   //button scan, 100ms time_tick
(0011) { 
(0012)   static u16 held_time_interval = 0;
(0013)   u8 key=0;
    001B0 24AA      CLR	R10
(0014)   u8 i=0;
    001B1 2744      CLR	R20
(0015)   
(0016)   DDRC |= 0x03;   //C0, C1 as input
    001B2 B384      IN	R24,0x14
    001B3 6083      ORI	R24,3
    001B4 BB84      OUT	0x14,R24
(0017)   PORTC |= 0x03;  //add pull_up
    001B5 B385      IN	R24,0x15
    001B6 6083      ORI	R24,3
    001B7 BB85      OUT	0x15,R24
(0018)   Delay(10);
    001B8 E00A      LDI	R16,0xA
    001B9 E010      LDI	R17,0
    001BA 940E 0EDC CALL	_Delay
(0019)   key = PINC;
    001BC B2A3      IN	R10,0x13
(0020)   key = ~key; //low level change to high level
    001BD 94A0      COM	R10
(0021) 
(0022)   switch(key&0x03)
    001BE 2D6A      MOV	R22,R10
    001BF 2777      CLR	R23
    001C0 7063      ANDI	R22,3
    001C1 7070      ANDI	R23,0
    001C2 3060      CPI	R22,0
    001C3 0767      CPC	R22,R23
    001C4 F069      BEQ	0x01D2
    001C5 3061      CPI	R22,1
    001C6 E0E0      LDI	R30,0
    001C7 077E      CPC	R23,R30
    001C8 F0B1      BEQ	0x01DF
    001C9 3062      CPI	R22,2
    001CA E0E0      LDI	R30,0
    001CB 077E      CPC	R23,R30
    001CC F101      BEQ	0x01ED
    001CD 3063      CPI	R22,3
    001CE E0E0      LDI	R30,0
    001CF 077E      CPC	R23,R30
    001D0 F151      BEQ	0x01FB
    001D1 C037      RJMP	0x0209
(0023)   {
(0024)     case 0x00:
(0025)     	button[0].value = (button[0].value<<1 | 0) & 0x03;  //JP1
    001D2 9180 0062 LDS	R24,i
    001D4 0F88      LSL	R24
    001D5 7083      ANDI	R24,3
    001D6 9380 0062 STS	i,R24
(0026)     	button[1].value = (button[1].value<<1 | 0) & 0x03;  //JP2
    001D8 9180 006A LDS	R24,maxVal
    001DA 0F88      LSL	R24
    001DB 7083      ANDI	R24,3
    001DC 9380 006A STS	maxVal,R24
(0027)   		break;
    001DE C02A      RJMP	0x0209
(0028)     case 0x01: 
(0029)         button[0].value = (button[0].value<<1 | 1) & 0x03;
    001DF 9180 0062 LDS	R24,i
    001E1 0F88      LSL	R24
    001E2 6081      ORI	R24,1
    001E3 7083      ANDI	R24,3
    001E4 9380 0062 STS	i,R24
(0030)     	button[1].value = (button[1].value<<1 | 0) & 0x03;
    001E6 9180 006A LDS	R24,maxVal
    001E8 0F88      LSL	R24
    001E9 7083      ANDI	R24,3
    001EA 9380 006A STS	maxVal,R24
(0031) 	    break;
    001EC C01C      RJMP	0x0209
(0032)     case 0x02:
(0033)         button[0].value = (button[0].value<<1 | 0) & 0x03;
    001ED 9180 0062 LDS	R24,i
    001EF 0F88      LSL	R24
    001F0 7083      ANDI	R24,3
    001F1 9380 0062 STS	i,R24
(0034)     	button[1].value = (button[1].value<<1 | 1) & 0x03;
    001F3 9180 006A LDS	R24,maxVal
    001F5 0F88      LSL	R24
    001F6 6081      ORI	R24,1
    001F7 7083      ANDI	R24,3
    001F8 9380 006A STS	maxVal,R24
(0035) 	    break;
    001FA C00E      RJMP	0x0209
(0036) 	case 0x03:
(0037)         button[0].value = (button[0].value<<1 | 1) & 0x03;
    001FB 9180 0062 LDS	R24,i
    001FD 0F88      LSL	R24
    001FE 6081      ORI	R24,1
    001FF 7083      ANDI	R24,3
    00200 9380 0062 STS	i,R24
(0038)     	button[1].value = (button[1].value<<1 | 1) & 0x03;
    00202 9180 006A LDS	R24,maxVal
    00204 0F88      LSL	R24
    00205 6081      ORI	R24,1
    00206 7083      ANDI	R24,3
    00207 9380 006A STS	maxVal,R24
(0039) 	    break;
(0040)     default:	
(0041)       break;
(0042)   }    	 
(0043)    
(0044)   for(i=0; i<2; i++)
    00209 2744      CLR	R20
    0020A C164      RJMP	0x036F
(0045)   {
(0046)   	button[i].prevState = button[i].state;
    0020B 2E24      MOV	R2,R20
    0020C 2433      CLR	R3
    0020D 0C22      LSL	R2
    0020E 1C33      ROL	R3
    0020F 0C22      LSL	R2
    00210 1C33      ROL	R3
    00211 0C22      LSL	R2
    00212 1C33      ROL	R3
    00213 0121      MOVW	R4,R2
    00214 E681      LDI	R24,0x61
    00215 E090      LDI	R25,0
    00216 01F1      MOVW	R30,R2
    00217 0FE8      ADD	R30,R24
    00218 1FF9      ADC	R31,R25
    00219 8020      LD	R2,Z
    0021A E680      LDI	R24,0x60
    0021B E090      LDI	R25,0
    0021C 01F2      MOVW	R30,R4
    0021D 0FE8      ADD	R30,R24
    0021E 1FF9      ADC	R31,R25
    0021F 8220      ST	Z,R2
(0047)   	switch(button[i].value)
    00220 E682      LDI	R24,0x62
    00221 E090      LDI	R25,0
    00222 2FE4      MOV	R30,R20
    00223 27FF      CLR	R31
    00224 0FEE      LSL	R30
    00225 1FFF      ROL	R31
    00226 0FEE      LSL	R30
    00227 1FFF      ROL	R31
    00228 0FEE      LSL	R30
    00229 1FFF      ROL	R31
    0022A 0FE8      ADD	R30,R24
    0022B 1FF9      ADC	R31,R25
    0022C 8160      LD	R22,Z
    0022D 2777      CLR	R23
    0022E 3060      CPI	R22,0
    0022F 0767      CPC	R22,R23
    00230 F081      BEQ	0x0241
    00231 3061      CPI	R22,1
    00232 E0E0      LDI	R30,0
    00233 077E      CPC	R23,R30
    00234 F409      BNE	0x0236
    00235 C044      RJMP	0x027A
    00236 3062      CPI	R22,2
    00237 E0E0      LDI	R30,0
    00238 077E      CPC	R23,R30
    00239 F409      BNE	0x023B
    0023A C07C      RJMP	0x02B7
    0023B 3063      CPI	R22,3
    0023C E0E0      LDI	R30,0
    0023D 077E      CPC	R23,R30
    0023E F409      BNE	0x0240
    0023F C0B4      RJMP	0x02F4
    00240 C12D      RJMP	0x036E
(0048)   	{
(0049)   		case 0x00:
(0050)   			button[i].state = BUTTON_STATE_NOT_PRESSED;
    00241 E681      LDI	R24,0x61
    00242 E090      LDI	R25,0
    00243 2FE4      MOV	R30,R20
    00244 27FF      CLR	R31
    00245 0FEE      LSL	R30
    00246 1FFF      ROL	R31
    00247 0FEE      LSL	R30
    00248 1FFF      ROL	R31
    00249 0FEE      LSL	R30
    0024A 1FFF      ROL	R31
    0024B 0FE8      ADD	R30,R24
    0024C 1FF9      ADC	R31,R25
    0024D E081      LDI	R24,1
    0024E 8380      ST	Z,R24
(0051) 			button[i].pressedFlag = FALSE;
    0024F E686      LDI	R24,0x66
    00250 E090      LDI	R25,0
    00251 2FE4      MOV	R30,R20
    00252 27FF      CLR	R31
    00253 0FEE      LSL	R30
    00254 1FFF      ROL	R31
    00255 0FEE      LSL	R30
    00256 1FFF      ROL	R31
    00257 0FEE      LSL	R30
    00258 1FFF      ROL	R31
    00259 0FE8      ADD	R30,R24
    0025A 1FF9      ADC	R31,R25
    0025B 2422      CLR	R2
    0025C 8220      ST	Z,R2
(0052) 			//button[i].releasedFlag = FALSE;
(0053) 			button[i].holdTime = 0;
    0025D E683      LDI	R24,0x63
    0025E E090      LDI	R25,0
    0025F 2FE4      MOV	R30,R20
    00260 27FF      CLR	R31
    00261 0FEE      LSL	R30
    00262 1FFF      ROL	R31
    00263 0FEE      LSL	R30
    00264 1FFF      ROL	R31
    00265 0FEE      LSL	R30
    00266 1FFF      ROL	R31
    00267 0FE8      ADD	R30,R24
    00268 1FF9      ADC	R31,R25
    00269 2433      CLR	R3
    0026A 8231      STD	Z+1,R3
    0026B 8220      ST	Z,R2
(0054)   			button[i].heldFlag = FALSE;
    0026C E685      LDI	R24,0x65
    0026D E090      LDI	R25,0
    0026E 2FE4      MOV	R30,R20
    0026F 27FF      CLR	R31
    00270 0FEE      LSL	R30
    00271 1FFF      ROL	R31
    00272 0FEE      LSL	R30
    00273 1FFF      ROL	R31
    00274 0FEE      LSL	R30
    00275 1FFF      ROL	R31
    00276 0FE8      ADD	R30,R24
    00277 1FF9      ADC	R31,R25
    00278 8220      ST	Z,R2
(0055)   			break;
    00279 C0F4      RJMP	0x036E
(0056)   			
(0057)   		case 0x01:
(0058)   			button[i].state = BUTTON_STATE_PRESSED;
    0027A E681      LDI	R24,0x61
    0027B E090      LDI	R25,0
    0027C 2FE4      MOV	R30,R20
    0027D 27FF      CLR	R31
    0027E 0FEE      LSL	R30
    0027F 1FFF      ROL	R31
    00280 0FEE      LSL	R30
    00281 1FFF      ROL	R31
    00282 0FEE      LSL	R30
    00283 1FFF      ROL	R31
    00284 0FE8      ADD	R30,R24
    00285 1FF9      ADC	R31,R25
    00286 E082      LDI	R24,2
    00287 8380      ST	Z,R24
(0059) 			button[i].pressedFlag = TRUE;
    00288 E686      LDI	R24,0x66
    00289 E090      LDI	R25,0
    0028A 2FE4      MOV	R30,R20
    0028B 27FF      CLR	R31
    0028C 0FEE      LSL	R30
    0028D 1FFF      ROL	R31
    0028E 0FEE      LSL	R30
    0028F 1FFF      ROL	R31
    00290 0FEE      LSL	R30
    00291 1FFF      ROL	R31
    00292 0FE8      ADD	R30,R24
    00293 1FF9      ADC	R31,R25
    00294 E081      LDI	R24,1
    00295 8380      ST	Z,R24
(0060) 			button[i].releasedFlag = FALSE;
    00296 E687      LDI	R24,0x67
    00297 E090      LDI	R25,0
    00298 2FE4      MOV	R30,R20
    00299 27FF      CLR	R31
    0029A 0FEE      LSL	R30
    0029B 1FFF      ROL	R31
    0029C 0FEE      LSL	R30
    0029D 1FFF      ROL	R31
    0029E 0FEE      LSL	R30
    0029F 1FFF      ROL	R31
    002A0 0FE8      ADD	R30,R24
    002A1 1FF9      ADC	R31,R25
    002A2 2422      CLR	R2
    002A3 8220      ST	Z,R2
(0061) 			button[i].heldFlag = FALSE;
    002A4 E685      LDI	R24,0x65
    002A5 E090      LDI	R25,0
    002A6 2FE4      MOV	R30,R20
    002A7 27FF      CLR	R31
    002A8 0FEE      LSL	R30
    002A9 1FFF      ROL	R31
    002AA 0FEE      LSL	R30
    002AB 1FFF      ROL	R31
    002AC 0FEE      LSL	R30
    002AD 1FFF      ROL	R31
    002AE 0FE8      ADD	R30,R24
    002AF 1FF9      ADC	R31,R25
    002B0 8220      ST	Z,R2
(0062) 			if(i==0)
    002B1 2344      TST	R20
    002B2 F401      BNE	0x02B3
(0063) 			{
(0064) 			  //LedLight(LED_D1, ON);
(0065) 			}
(0066) 			
(0067) 			if(i==1)
    002B3 3041      CPI	R20,1
    002B4 F009      BEQ	0x02B6
    002B5 C0B8      RJMP	0x036E
(0068) 			{
(0069) 			  //LedLight(LED_D2, ON);
(0070) 			}
(0071)   			break;
    002B6 C0B7      RJMP	0x036E
(0072)   		
(0073)   		case 0x02:
(0074)   			button[i].state = BUTTON_STATE_RELEASED;
    002B7 E681      LDI	R24,0x61
    002B8 E090      LDI	R25,0
    002B9 2FE4      MOV	R30,R20
    002BA 27FF      CLR	R31
    002BB 0FEE      LSL	R30
    002BC 1FFF      ROL	R31
    002BD 0FEE      LSL	R30
    002BE 1FFF      ROL	R31
    002BF 0FEE      LSL	R30
    002C0 1FFF      ROL	R31
    002C1 0FE8      ADD	R30,R24
    002C2 1FF9      ADC	R31,R25
    002C3 E084      LDI	R24,4
    002C4 8380      ST	Z,R24
(0075) 			button[i].releasedFlag = TRUE;
    002C5 E687      LDI	R24,0x67
    002C6 E090      LDI	R25,0
    002C7 2FE4      MOV	R30,R20
    002C8 27FF      CLR	R31
    002C9 0FEE      LSL	R30
    002CA 1FFF      ROL	R31
    002CB 0FEE      LSL	R30
    002CC 1FFF      ROL	R31
    002CD 0FEE      LSL	R30
    002CE 1FFF      ROL	R31
    002CF 0FE8      ADD	R30,R24
    002D0 1FF9      ADC	R31,R25
    002D1 E081      LDI	R24,1
    002D2 8380      ST	Z,R24
(0076) 			button[i].pressedFlag = FALSE;
    002D3 E686      LDI	R24,0x66
    002D4 E090      LDI	R25,0
    002D5 2FE4      MOV	R30,R20
    002D6 27FF      CLR	R31
    002D7 0FEE      LSL	R30
    002D8 1FFF      ROL	R31
    002D9 0FEE      LSL	R30
    002DA 1FFF      ROL	R31
    002DB 0FEE      LSL	R30
    002DC 1FFF      ROL	R31
    002DD 0FE8      ADD	R30,R24
    002DE 1FF9      ADC	R31,R25
    002DF 2422      CLR	R2
    002E0 8220      ST	Z,R2
(0077) 			button[i].heldFlag = FALSE;
    002E1 E685      LDI	R24,0x65
    002E2 E090      LDI	R25,0
    002E3 2FE4      MOV	R30,R20
    002E4 27FF      CLR	R31
    002E5 0FEE      LSL	R30
    002E6 1FFF      ROL	R31
    002E7 0FEE      LSL	R30
    002E8 1FFF      ROL	R31
    002E9 0FEE      LSL	R30
    002EA 1FFF      ROL	R31
    002EB 0FE8      ADD	R30,R24
    002EC 1FF9      ADC	R31,R25
    002ED 8220      ST	Z,R2
(0078) 			
(0079) 			if(i==0)
    002EE 2344      TST	R20
    002EF F401      BNE	0x02F0
(0080) 			{
(0081) 			  //LedLight(LED_D1, OFF);
(0082) 			}
(0083) 			
(0084) 			if(i==1)
    002F0 3041      CPI	R20,1
    002F1 F009      BEQ	0x02F3
    002F2 C07B      RJMP	0x036E
(0085) 			{
(0086) 			  //LedLight(LED_D2, OFF);
(0087) 			}
(0088)   			break;
    002F3 C07A      RJMP	0x036E
(0089)   			
(0090)   		case 0x03:
(0091)   			button[i].state = BUTTON_STATE_HELD;
    002F4 E681      LDI	R24,0x61
    002F5 E090      LDI	R25,0
    002F6 2FE4      MOV	R30,R20
    002F7 27FF      CLR	R31
    002F8 0FEE      LSL	R30
    002F9 1FFF      ROL	R31
    002FA 0FEE      LSL	R30
    002FB 1FFF      ROL	R31
    002FC 0FEE      LSL	R30
    002FD 1FFF      ROL	R31
    002FE 0FE8      ADD	R30,R24
    002FF 1FF9      ADC	R31,R25
    00300 E083      LDI	R24,3
    00301 8380      ST	Z,R24
(0092) 			button[i].releasedFlag = FALSE;
    00302 E687      LDI	R24,0x67
    00303 E090      LDI	R25,0
    00304 2FE4      MOV	R30,R20
    00305 27FF      CLR	R31
    00306 0FEE      LSL	R30
    00307 1FFF      ROL	R31
    00308 0FEE      LSL	R30
    00309 1FFF      ROL	R31
    0030A 0FEE      LSL	R30
    0030B 1FFF      ROL	R31
    0030C 0FE8      ADD	R30,R24
    0030D 1FF9      ADC	R31,R25
    0030E 2422      CLR	R2
    0030F 8220      ST	Z,R2
(0093)   			button[i].holdTime++;	
    00310 E683      LDI	R24,0x63
    00311 E090      LDI	R25,0
    00312 2E24      MOV	R2,R20
    00313 2433      CLR	R3
    00314 0C22      LSL	R2
    00315 1C33      ROL	R3
    00316 0C22      LSL	R2
    00317 1C33      ROL	R3
    00318 0C22      LSL	R2
    00319 1C33      ROL	R3
    0031A 0E28      ADD	R2,R24
    0031B 1E39      ADC	R3,R25
    0031C 01F1      MOVW	R30,R2
    0031D 8180      LD	R24,Z
    0031E 8191      LDD	R25,Z+1
    0031F 9601      ADIW	R24,1
    00320 8391      STD	Z+1,R25
    00321 8380      ST	Z,R24
(0094) 			
(0095)   			if(button[i].holdTime > HOLD_TIME_3S)
    00322 E683      LDI	R24,0x63
    00323 E090      LDI	R25,0
    00324 2FE4      MOV	R30,R20
    00325 27FF      CLR	R31
    00326 0FEE      LSL	R30
    00327 1FFF      ROL	R31
    00328 0FEE      LSL	R30
    00329 1FFF      ROL	R31
    0032A 0FEE      LSL	R30
    0032B 1FFF      ROL	R31
    0032C 0FE8      ADD	R30,R24
    0032D 1FF9      ADC	R31,R25
    0032E 8020      LD	R2,Z
    0032F 8031      LDD	R3,Z+1
    00330 E18E      LDI	R24,0x1E
    00331 E090      LDI	R25,0
    00332 1582      CP	R24,R2
    00333 0593      CPC	R25,R3
    00334 F008      BCS	0x0336
    00335 C038      RJMP	0x036E
(0096)   			{
(0097)   				button[i].heldFlag = TRUE;
    00336 E685      LDI	R24,0x65
    00337 E090      LDI	R25,0
    00338 2FE4      MOV	R30,R20
    00339 27FF      CLR	R31
    0033A 0FEE      LSL	R30
    0033B 1FFF      ROL	R31
    0033C 0FEE      LSL	R30
    0033D 1FFF      ROL	R31
    0033E 0FEE      LSL	R30
    0033F 1FFF      ROL	R31
    00340 0FE8      ADD	R30,R24
    00341 1FF9      ADC	R31,R25
    00342 E081      LDI	R24,1
    00343 8380      ST	Z,R24
(0098) 				button[i].pressedFlag = FALSE;
    00344 E686      LDI	R24,0x66
    00345 E090      LDI	R25,0
    00346 2FE4      MOV	R30,R20
    00347 27FF      CLR	R31
    00348 0FEE      LSL	R30
    00349 1FFF      ROL	R31
    0034A 0FEE      LSL	R30
    0034B 1FFF      ROL	R31
    0034C 0FEE      LSL	R30
    0034D 1FFF      ROL	R31
    0034E 0FE8      ADD	R30,R24
    0034F 1FF9      ADC	R31,R25
    00350 2422      CLR	R2
    00351 8220      ST	Z,R2
(0099) 				held_time_interval = HOLD_TIME_3S - HOLD_TIME_0_5S;
    00352 E189      LDI	R24,0x19
    00353 E090      LDI	R25,0
    00354 9390 0071 STS	held_time_interval+1,R25
    00356 9380 0070 STS	held_time_interval,R24
(0100) 				//if(held_time_interval < HOLD_TIME_3S - HOLD_TIME_0_1S ) //100ms
(0101) 				//{
(0102) 				  //held_time_interval++; //at last it would fatest to 100ms
(0103) 				//}
(0104) 				button[i].holdTime = held_time_interval;
    00358 E683      LDI	R24,0x63
    00359 E090      LDI	R25,0
    0035A 2FE4      MOV	R30,R20
    0035B 27FF      CLR	R31
    0035C 0FEE      LSL	R30
    0035D 1FFF      ROL	R31
    0035E 0FEE      LSL	R30
    0035F 1FFF      ROL	R31
    00360 0FEE      LSL	R30
    00361 1FFF      ROL	R31
    00362 0FE8      ADD	R30,R24
    00363 1FF9      ADC	R31,R25
    00364 9020 0070 LDS	R2,held_time_interval
    00366 9030 0071 LDS	R3,held_time_interval+1
    00368 8231      STD	Z+1,R3
    00369 8220      ST	Z,R2
(0105) 				
(0106) 				if(i==0)
    0036A 2344      TST	R20
    0036B F401      BNE	0x036C
(0107) 				{
(0108) 					//LedBlink(LED_D1, BLINK_2HZ);
(0109) 					//LedLight(LED_D1, ON);
(0110) 					//LedLight(LED_D2, OFF);
(0111) 				}
(0112) 				
(0113) 				if(i==1)
    0036C 3041      CPI	R20,1
    0036D F401      BNE	0x036E
(0114) 				{
(0115) 					//LedLight(LED_D2, ON);
(0116) 					//LedLight(LED_D1, OFF);
(0117) 				}
(0118)   			}
(0119)   			break;
(0120)   			
(0121)   	  default:
(0122)   	  	break;
(0123)     }	
(0124)   }  
    0036E 9543      INC	R20
    0036F 3042      CPI	R20,2
(0125) }
_Con_Module_Init_Proc:
  temp_hv_value        --> Y,+17
  temp_resp_time       --> Y,+15
  temp_per_low         --> Y,+13
  temp_per_high        --> Y,+11
  temp_mt_empty        --> Y,+9
  temp_mt_full         --> Y,+7
  temp_addr_code       --> Y,+5
    00374 9763      SBIW	R28,0x13
FILE: C:\Users\junife\Documents\GitHub\LevelMeter_ICCAVR804\ICCAVR\src\control.c
(0001) #include <iom16v.h>
(0002) #include <macros.h>
(0003) #include "peripheral.h"
(0004) #include "variables.h"
(0005) #include "segDisp.h"
(0006) #include "led.h"
(0007) #include "button.h"
(0008) #include "memory.h"
(0009) #include "control.h"
(0010) #include "seg_HC164.h"
(0011) 
(0012) static u8  tickCnt = 0;
(0013) 
(0014) 	
(0015) void Con_Module_Init_Proc(void)
(0016) {
(0017)   ADDR_CODE_T    temp_addr_code;
(0018)   MT_FULL_T      temp_mt_full;
(0019)   MT_EMPTY_T     temp_mt_empty;
(0020)   PER_HIGH_T     temp_per_high;
(0021)   PER_LOW_T      temp_per_low;
(0022)   RESP_TIME_T    temp_resp_time;
(0023)   HV_800V_T      temp_hv_value;
(0024)   //EEPROM_Write_Bytes(SEQ_NUM_ADDR, &me_seq_num.year, sizeof(SEQ_NUM_T));
(0025)   //EEPROM_Write_Bytes(ADDR_CODE_ADDR, &me_addr_code.highByte, sizeof(ADDR_CODE_T));
(0026)   //EEPROM_Write_Bytes(HIGH_THRESH_ADDR, &me_high_thresh.highByte, sizeof(HIGH_THRESH_T));
(0027)   //EEPROM_Write_Bytes(LOW_THRESH_ADDR, &me_low_thresh.highByte, sizeof(LOW_THRESH_T));
(0028)   //EEPROM_Write_Bytes(OP_TIME_LOW_ADDR, &me_op_time.val[0], sizeof(OP_TIME_T));
(0029) 	  
(0030)   EEPROM_Read_Bytes(ADDR_CODE_ADDR, &temp_addr_code.highByte, sizeof(ADDR_CODE_T));
    00375 E082      LDI	R24,2
    00376 E090      LDI	R25,0
    00377 8399      STD	Y+1,R25
    00378 8388      ST	Y,R24
    00379 019E      MOVW	R18,R28
    0037A 5F2B      SUBI	R18,0xFB
    0037B 4F3F      SBCI	R19,0xFF
    0037C E100      LDI	R16,0x10
    0037D E010      LDI	R17,0
    0037E 940E 0E24 CALL	_EEPROM_Read_Bytes
(0031)   EEPROM_Read_Bytes(MT_FULL_ADDR, &temp_mt_full.highByte, sizeof(MT_FULL_T));
    00380 E082      LDI	R24,2
    00381 E090      LDI	R25,0
    00382 8399      STD	Y+1,R25
    00383 8388      ST	Y,R24
    00384 019E      MOVW	R18,R28
    00385 5F29      SUBI	R18,0xF9
    00386 4F3F      SBCI	R19,0xFF
    00387 E200      LDI	R16,0x20
    00388 E010      LDI	R17,0
    00389 940E 0E24 CALL	_EEPROM_Read_Bytes
(0032)   EEPROM_Read_Bytes(MT_EMPTY_ADDR, &temp_mt_empty.highByte, sizeof(MT_EMPTY_T));
    0038B E082      LDI	R24,2
    0038C E090      LDI	R25,0
    0038D 8399      STD	Y+1,R25
    0038E 8388      ST	Y,R24
    0038F 019E      MOVW	R18,R28
    00390 5F27      SUBI	R18,0xF7
    00391 4F3F      SBCI	R19,0xFF
    00392 E208      LDI	R16,0x28
    00393 E010      LDI	R17,0
    00394 940E 0E24 CALL	_EEPROM_Read_Bytes
(0033)   EEPROM_Read_Bytes(PER_HIGH_ADDR, &temp_per_high.highByte, sizeof(PER_HIGH_T));
    00396 E082      LDI	R24,2
    00397 E090      LDI	R25,0
    00398 8399      STD	Y+1,R25
    00399 8388      ST	Y,R24
    0039A 019E      MOVW	R18,R28
    0039B 5F25      SUBI	R18,0xF5
    0039C 4F3F      SBCI	R19,0xFF
    0039D E300      LDI	R16,0x30
    0039E E010      LDI	R17,0
    0039F 940E 0E24 CALL	_EEPROM_Read_Bytes
(0034)   EEPROM_Read_Bytes(PER_LOW_ADDR, &temp_per_low.highByte, sizeof(PER_LOW_T));
    003A1 E082      LDI	R24,2
    003A2 E090      LDI	R25,0
    003A3 8399      STD	Y+1,R25
    003A4 8388      ST	Y,R24
    003A5 019E      MOVW	R18,R28
    003A6 5F23      SUBI	R18,0xF3
    003A7 4F3F      SBCI	R19,0xFF
    003A8 E308      LDI	R16,0x38
    003A9 E010      LDI	R17,0
    003AA 940E 0E24 CALL	_EEPROM_Read_Bytes
(0035)   EEPROM_Read_Bytes(RESP_TIME_ADDR, &temp_resp_time.highByte, sizeof(RESP_TIME_T));
    003AC E082      LDI	R24,2
    003AD E090      LDI	R25,0
    003AE 8399      STD	Y+1,R25
    003AF 8388      ST	Y,R24
    003B0 019E      MOVW	R18,R28
    003B1 5F21      SUBI	R18,0xF1
    003B2 4F3F      SBCI	R19,0xFF
    003B3 E400      LDI	R16,0x40
    003B4 E010      LDI	R17,0
    003B5 940E 0E24 CALL	_EEPROM_Read_Bytes
(0036)   EEPROM_Read_Bytes(HV_800V_ADDR, &temp_hv_value.highByte, sizeof(HV_800V_T));
    003B7 E082      LDI	R24,2
    003B8 E090      LDI	R25,0
    003B9 8399      STD	Y+1,R25
    003BA 8388      ST	Y,R24
    003BB 019E      MOVW	R18,R28
    003BC 5E2F      SUBI	R18,0xEF
    003BD 4F3F      SBCI	R19,0xFF
    003BE E600      LDI	R16,0x60
    003BF E010      LDI	R17,0
    003C0 940E 0E24 CALL	_EEPROM_Read_Bytes
(0037)   
(0038)   g_addr_code = temp_addr_code.highByte*100 + temp_addr_code.lowByte;
    003C2 802D      LDD	R2,Y+5
    003C3 E684      LDI	R24,0x64
    003C4 9D82      MUL	R24,R2
    003C5 0110      MOVW	R2,R0
    003C6 804E      LDD	R4,Y+6
    003C7 2455      CLR	R5
    003C8 0C24      ADD	R2,R4
    003C9 1C35      ADC	R3,R5
    003CA 9230 0329 STS	g_addr_code+1,R3
    003CC 9220 0328 STS	g_addr_code,R2
(0039)   g_mt_full = temp_mt_full.highByte*100 + temp_mt_full.lowByte;
    003CE 802F      LDD	R2,Y+7
    003CF 9D82      MUL	R24,R2
    003D0 0110      MOVW	R2,R0
    003D1 8448      LDD	R4,Y+8
    003D2 2455      CLR	R5
    003D3 0C24      ADD	R2,R4
    003D4 1C35      ADC	R3,R5
    003D5 9230 0327 STS	g_mt_full+1,R3
    003D7 9220 0326 STS	g_mt_full,R2
(0040)   g_mt_empty = temp_mt_empty.highByte*100 + temp_mt_empty.lowByte;
    003D9 8429      LDD	R2,Y+9
    003DA 9D82      MUL	R24,R2
    003DB 0110      MOVW	R2,R0
    003DC 844A      LDD	R4,Y+10
    003DD 2455      CLR	R5
    003DE 0C24      ADD	R2,R4
    003DF 1C35      ADC	R3,R5
    003E0 9230 0325 STS	g_mt_empty+1,R3
    003E2 9220 0324 STS	g_mt_empty,R2
(0041)   g_per_high = temp_per_high.highByte*100 + temp_per_high.lowByte;
    003E4 842B      LDD	R2,Y+11
    003E5 9D82      MUL	R24,R2
    003E6 0110      MOVW	R2,R0
    003E7 844C      LDD	R4,Y+12
    003E8 2455      CLR	R5
    003E9 0C24      ADD	R2,R4
    003EA 1C35      ADC	R3,R5
    003EB 9230 0323 STS	g_per_high+1,R3
    003ED 9220 0322 STS	g_per_high,R2
(0042)   g_per_low = temp_per_low.highByte*100 + temp_per_low.lowByte;
    003EF 842D      LDD	R2,Y+13
    003F0 9D82      MUL	R24,R2
    003F1 0110      MOVW	R2,R0
    003F2 844E      LDD	R4,Y+14
    003F3 2455      CLR	R5
    003F4 0C24      ADD	R2,R4
    003F5 1C35      ADC	R3,R5
    003F6 9230 0321 STS	g_per_low+1,R3
    003F8 9220 0320 STS	g_per_low,R2
(0043)   g_resp_time = temp_resp_time.highByte*100 + temp_resp_time.lowByte;
    003FA 842F      LDD	R2,Y+15
    003FB 9D82      MUL	R24,R2
    003FC 0110      MOVW	R2,R0
    003FD 8848      LDD	R4,Y+16
    003FE 2455      CLR	R5
    003FF 0C24      ADD	R2,R4
    00400 1C35      ADC	R3,R5
    00401 9230 031F STS	g_resp_time+1,R3
    00403 9220 031E STS	g_resp_time,R2
(0044)   g_hv_value = temp_hv_value.highByte*100 + temp_hv_value.lowByte;
    00405 8829      LDD	R2,Y+17
    00406 9D82      MUL	R24,R2
    00407 0110      MOVW	R2,R0
    00408 884A      LDD	R4,Y+18
    00409 2455      CLR	R5
    0040A 0C24      ADD	R2,R4
    0040B 1C35      ADC	R3,R5
    0040C 9230 031D STS	g_hv_value+1,R3
    0040E 9220 031C STS	g_hv_value,R2
(0045)   
(0046)   KZ1_OUT_LOW();   
    00410 9894      CBI	0x12,4
(0047)   KZ2_OUT_HIGH(); 
    00411 9A95      SBI	0x12,5
(0048)   
(0049)   RL1_OPEN();  
    00412 9AAA      SBI	0x15,2
(0050)   RL2_OPEN();  
    00413 9AAB      SBI	0x15,3
(0051)   
(0052)   if(tickCnt<2)
    00414 9180 0072 LDS	R24,control.c:tickCnt
    00416 3082      CPI	R24,2
    00417 F4E8      BCC	0x0435
(0053)   {
(0054)     if(timer_1000ms_flag)
    00418 9020 032A LDS	R2,timer_1000ms_flag
    0041A 2022      TST	R2
    0041B F409      BNE	0x041D
    0041C C049      RJMP	0x0466
(0055) 	{
(0056) 	  timer_1000ms_flag = FALSE;
    0041D 2422      CLR	R2
    0041E 9220 032A STS	timer_1000ms_flag,R2
(0057) 	  if(tickCnt%2 == 0)
    00420 E012      LDI	R17,2
    00421 2F08      MOV	R16,R24
    00422 940E 11D6 CALL	mod8u
    00424 2300      TST	R16
    00425 F449      BNE	0x042F
(0058) 	  {
(0059) 	  	Seg_164_Number(g_addr_code, SEG_COLOR_GREEN, MARK_NULL);
    00426 E082      LDI	R24,2
    00427 8388      ST	Y,R24
    00428 E021      LDI	R18,1
    00429 9100 0328 LDS	R16,g_addr_code
    0042B 9110 0329 LDS	R17,g_addr_code+1
    0042D 940E 104F CALL	_Seg_164_Number
(0060) 		//LedLight(LED_D1, OFF);
(0061) 	  }
(0062) 	  else
(0063) 	  {
(0064) 		//LedLight(LED_D1, ON);
(0065) 	  }
(0066) 	  tickCnt++;
    0042F 9180 0072 LDS	R24,control.c:tickCnt
    00431 5F8F      SUBI	R24,0xFF
    00432 9380 0072 STS	control.c:tickCnt,R24
(0067) 	}
(0068)   }
    00434 C031      RJMP	0x0466
(0069)   else if(tickCnt<5)
    00435 9180 0072 LDS	R24,control.c:tickCnt
    00437 3085      CPI	R24,5
    00438 F4E0      BCC	0x0455
(0070)   {
(0071)     if(timer_1000ms_flag)
    00439 9020 032A LDS	R2,timer_1000ms_flag
    0043B 2022      TST	R2
    0043C F079      BEQ	0x044C
(0072) 	{
(0073) 	  timer_1000ms_flag = FALSE;
    0043D 2422      CLR	R2
    0043E 9220 032A STS	timer_1000ms_flag,R2
(0074) 	  tickCnt++;
    00440 5F8F      SUBI	R24,0xFF
    00441 9380 0072 STS	control.c:tickCnt,R24
(0075) 	  Seg_164_Alpha(H, U, g, E, SEG_COLOR_RED);
    00443 822C      STD	Y+4,R2
    00444 E084      LDI	R24,4
    00445 838A      STD	Y+2,R24
    00446 E086      LDI	R24,6
    00447 8388      ST	Y,R24
    00448 E02A      LDI	R18,0xA
    00449 E009      LDI	R16,0x9
    0044A 940E 10D3 CALL	_Seg_164_Alpha
(0076) 	  //Seg_164_Number(8888, SEG_COLOR_RED, MARK_NULL);
(0077) 	}
(0078) 	LedLight(LED_D1, ON);
    0044C E021      LDI	R18,1
    0044D E001      LDI	R16,1
    0044E 940E 0D37 CALL	_LedLight
(0079) 	LedLight(LED_D2, ON);
    00450 E021      LDI	R18,1
    00451 E002      LDI	R16,2
    00452 940E 0D37 CALL	_LedLight
(0080)   }
    00454 C011      RJMP	0x0466
(0081)   else
(0082)   {
(0083)     LedLight(LED_D1, OFF);
    00455 2722      CLR	R18
    00456 E001      LDI	R16,1
    00457 940E 0D37 CALL	_LedLight
(0084)     LedLight(LED_D2, OFF);
    00459 2722      CLR	R18
    0045A E002      LDI	R16,2
    0045B 940E 0D37 CALL	_LedLight
(0085)     module_prevState = MODULE_STATE_INIT;
    0045D E081      LDI	R24,1
    0045E 9380 01EC STS	module_prevState,R24
(0086)     module_state = MODULE_STATE_WORK_NORM;
    00460 E082      LDI	R24,2
    00461 9380 01EB STS	module_state,R24
(0087) 	tickCnt = 0;
    00463 2422      CLR	R2
    00464 9220 0072 STS	control.c:tickCnt,R2
(0088)   }
    00466 9663      ADIW	R28,0x13
    00467 9508      RET
_Con_Module_Work_Norm_Proc:
    00468 92AA      ST	-Y,R10
(0089) }
(0090) 
(0091) void Con_Module_Work_Norm_Proc(void)
(0092) {
(0093)   RL1_CLOSE();
    00469 98AA      CBI	0x15,2
(0094)   RL2_CLOSE();
    0046A 98AB      CBI	0x15,3
(0095)   materialDetect();  //change module state in this function
    0046B D0C2      RCALL	_materialDetect
(0096)   
(0097)   if(Per_Bypass_Ms(1000) == TRUE)
    0046C EE08      LDI	R16,0xE8
    0046D E013      LDI	R17,3
    0046E 940E 0EF3 CALL	_Per_Bypass_Ms
    00470 3001      CPI	R16,1
    00471 F409      BNE	0x0473
(0098)   {
(0099)     buttonDetect();
    00472 D270      RCALL	_buttonDetect
(0100)   }
(0101) 
(0102)   if(PORT_KZ1_HIGH_IN() == HIGH)
    00473 D038      RCALL	_PORT_KZ1_HIGH_IN
    00474 3001      CPI	R16,1
    00475 F401      BNE	0x0476
(0103)   {
(0104)   }
(0105)   else
(0106)   {
(0107)   }
(0108) 
(0109)   if(PORT_KZ2_LOW_IN() == LOW)
    00476 D045      RCALL	_PORT_KZ2_LOW_IN
    00477 2EA0      MOV	R10,R16
    00478 2300      TST	R16
    00479 F401      BNE	0x047A
(0110)   {
(0111)   }
(0112)   else
(0113)   {
(0114)   }
    0047A 90A9      LD	R10,Y+
    0047B 9508      RET
(0115) }
(0116) 
(0117) void Con_Module_Work_Warn_Proc(void)
(0118) {
(0119)   RL1_OPEN();
_Con_Module_Work_Warn_Proc:
    0047C 9AAA      SBI	0x15,2
(0120)   RL2_OPEN();
    0047D 9AAB      SBI	0x15,3
(0121)   materialDetect();  //change module state in this function
    0047E D0AF      RCALL	_materialDetect
(0122)   
(0123)   if(Per_Bypass_Ms(1000) == TRUE)
    0047F EE08      LDI	R16,0xE8
    00480 E013      LDI	R17,3
    00481 940E 0EF3 CALL	_Per_Bypass_Ms
    00483 3001      CPI	R16,1
    00484 F409      BNE	0x0486
(0124)   {
(0125)     buttonDetect();
    00485 D25D      RCALL	_buttonDetect
(0126)   }
    00486 9508      RET
(0127) }
(0128) 
(0129) void Con_Module_Communicate_Proc(void)
(0130) {
_Con_Module_Communicate_Proc:
    00487 9508      RET
(0131) }
(0132) 
(0133) void Con_Module_Service_Proc(void)
(0134) {
(0135)   if(Per_Bypass_Ms(1000) == TRUE)
_Con_Module_Service_Proc:
    00488 EE08      LDI	R16,0xE8
    00489 E013      LDI	R17,3
    0048A 940E 0EF3 CALL	_Per_Bypass_Ms
    0048C 3001      CPI	R16,1
    0048D F409      BNE	0x048F
(0136)   {
(0137)     buttonDetect();
    0048E D254      RCALL	_buttonDetect
(0138)   }
    0048F 9508      RET
(0139) }
(0140) 
(0141) void Con_Module_Error_Proc(void)
(0142) {
_Con_Module_Error_Proc:
    00490 9508      RET
(0143) }
(0144) 
(0145) void Con_Module_Quit_Proc(void)
(0146) {
(0147)     if((button[1].heldFlag == FALSE)&&(button[0].heldFlag == FALSE))
_Con_Module_Quit_Proc:
    00491 9020 006D LDS	R2,maxVal+3
    00493 2022      TST	R2
    00494 F4B1      BNE	0x04AB
    00495 9020 0065 LDS	R2,ad_cnt
    00497 2022      TST	R2
    00498 F491      BNE	0x04AB
(0148) 	{
(0149) 	    module_state = MODULE_STATE_INIT;
    00499 E081      LDI	R24,1
    0049A 9380 01EB STS	module_state,R24
(0150) 		module_quit_flag = FALSE;
    0049C 2422      CLR	R2
    0049D 9220 01CE STS	module_quit_flag,R2
(0151) 		
(0152) 		LedBlink(LED_D1, BLINK_2HZ);
    0049F E022      LDI	R18,2
    004A0 E001      LDI	R16,1
    004A1 940E 0D49 CALL	_LedBlink
(0153) 	    LedBlink(LED_D2, BLINK_2HZ);
    004A3 E022      LDI	R18,2
    004A4 E002      LDI	R16,2
    004A5 940E 0D49 CALL	_LedBlink
(0154) 	    Per_Dly_Ms(2000);
    004A7 ED00      LDI	R16,0xD0
    004A8 E017      LDI	R17,7
    004A9 940E 0EE5 CALL	_Per_Dly_Ms
(0155) 	}
    004AB 9508      RET
(0156) }
(0157) 
(0158) u8 PORT_KZ1_HIGH_IN(void)    
(0159) { 
(0160)     u8 val = (PIND & BIT(3)) >> 3;  //not PORTD, but should use PIND
_PORT_KZ1_HIGH_IN:
  val                  --> R16
    004AC B300      IN	R16,0x10
    004AD 2711      CLR	R17
    004AE 7008      ANDI	R16,0x8
    004AF 7010      ANDI	R17,0
    004B0 9515      ASR	R17
    004B1 9507      ROR	R16
    004B2 9515      ASR	R17
    004B3 9507      ROR	R16
    004B4 9515      ASR	R17
    004B5 9507      ROR	R16
(0161) 	if(val == HIGH)
    004B6 3001      CPI	R16,1
    004B7 F411      BNE	0x04BA
(0162) 	{
(0163) 	    return TRUE;
    004B8 E001      LDI	R16,1
    004B9 C001      RJMP	0x04BB
(0164) 	}
(0165) 	else
(0166) 	{
(0167) 	    return FALSE;
    004BA 2700      CLR	R16
    004BB 9508      RET
(0168) 	}
(0169) }
(0170) 
(0171) u8 PORT_KZ2_LOW_IN(void)    
(0172) {   
(0173)     u8 val = (PIND & BIT(2)) >> 2;
_PORT_KZ2_LOW_IN:
  val                  --> R16
    004BC B300      IN	R16,0x10
    004BD 2711      CLR	R17
    004BE 7004      ANDI	R16,4
    004BF 7010      ANDI	R17,0
    004C0 9515      ASR	R17
    004C1 9507      ROR	R16
    004C2 9515      ASR	R17
    004C3 9507      ROR	R16
(0174)     if(val == LOW)
    004C4 2300      TST	R16
    004C5 F411      BNE	0x04C8
(0175) 	{
(0176) 	    return TRUE;
    004C6 E001      LDI	R16,1
    004C7 C001      RJMP	0x04C9
(0177) 	}
(0178) 	else
(0179) 	{
(0180) 	    return FALSE;
    004C8 2700      CLR	R16
    004C9 9508      RET
_getMaxVal:
  temp                 --> R12
  i                    --> R20
  maxArray             --> R10
  inData               --> R18
  length               --> R16
    004CA 940E 123F CALL	push_xgset303C
    004CC 80AE      LDD	R10,Y+6
    004CD 80BF      LDD	R11,Y+7
(0181) 	}
(0182) }
(0183) 
(0184) void getMaxVal(u16 length, u16 inData, u16* maxArray)
(0185) {
(0186)   u16 i = 0;
(0187)   u16 temp = 0;
    004CE 24CC      CLR	R12
    004CF 24DD      CLR	R13
(0188)   for(i=0; i<length; i++)
    004D0 2744      CLR	R20
    004D1 2755      CLR	R21
    004D2 C01B      RJMP	0x04EE
(0189)   {
(0190) 	if(inData > maxArray[i])
    004D3 01FA      MOVW	R30,R20
    004D4 0FEE      LSL	R30
    004D5 1FFF      ROL	R31
    004D6 0DEA      ADD	R30,R10
    004D7 1DFB      ADC	R31,R11
    004D8 8020      LD	R2,Z
    004D9 8031      LDD	R3,Z+1
    004DA 1622      CP	R2,R18
    004DB 0633      CPC	R3,R19
    004DC F478      BCC	0x04EC
(0191) 	{ 
(0192) 	  temp = maxArray[i];
    004DD 01FA      MOVW	R30,R20
    004DE 0FEE      LSL	R30
    004DF 1FFF      ROL	R31
    004E0 0DEA      ADD	R30,R10
    004E1 1DFB      ADC	R31,R11
    004E2 80C0      LD	R12,Z
    004E3 80D1      LDD	R13,Z+1
(0193) 	  maxArray[i] = inData;
    004E4 01FA      MOVW	R30,R20
    004E5 0FEE      LSL	R30
    004E6 1FFF      ROL	R31
    004E7 0DEA      ADD	R30,R10
    004E8 1DFB      ADC	R31,R11
    004E9 8331      STD	Z+1,R19
    004EA 8320      ST	Z,R18
(0194) 	  inData = temp;
    004EB 0196      MOVW	R18,R12
(0195) 	}
(0196)   }
    004EC 5F4F      SUBI	R20,0xFF
    004ED 4F5F      SBCI	R21,0xFF
    004EE 1740      CP	R20,R16
    004EF 0751      CPC	R21,R17
    004F0 F310      BCS	0x04D3
    004F1 940C 1246 JMP	pop_xgset303C
_getAvgVal:
  j                    --> Y,+1
  temp                 --> R10
  inAvg                --> Y,+4
  inSum                --> Y,+0
  i                    --> R20
  inArray              --> R18
  length               --> R16
    004F3 940E 121D CALL	push_xgset300C
    004F5 9728      SBIW	R28,0x8
(0197) }
(0198) 
(0199) u32 getAvgVal(u16 length, u16* inArray)
(0200) {
(0201)   u16 i,j;
(0202)   u16 temp = 0;
    004F6 24AA      CLR	R10
    004F7 24BB      CLR	R11
(0203)   u32 inAvg = 0, inSum = 0;
    004F8 E080      LDI	R24,0
    004F9 838C      STD	Y+4,R24
    004FA 838D      STD	Y+5,R24
    004FB 838E      STD	Y+6,R24
    004FC 838F      STD	Y+7,R24
    004FD E080      LDI	R24,0
    004FE 8388      ST	Y,R24
    004FF 8389      STD	Y+1,R24
    00500 838A      STD	Y+2,R24
    00501 838B      STD	Y+3,R24
(0204)   
(0205)   /*for(i=0; i<length; i++)
(0206)   {
(0207)     for(j=i; j<length-1; j++)
(0208) 	{
(0209) 	  if(inArray[j]<inArray[j+1])
(0210) 	  {
(0211) 	    temp = inArray[j];
(0212) 	    inArray[j] = inArray[j+1];
(0213) 		inArray[j+1] = temp;
(0214) 	  }
(0215) 	}
(0216)   }*/
(0217)   
(0218)   for(i=0; i<length; i++)
    00502 2744      CLR	R20
    00503 2755      CLR	R21
    00504 C017      RJMP	0x051C
(0219)   {
(0220)     inSum += inArray[i];   //original(128-64 =64);  now(128-0=128)
    00505 01FA      MOVW	R30,R20
    00506 0FEE      LSL	R30
    00507 1FFF      ROL	R31
    00508 0FE2      ADD	R30,R18
    00509 1FF3      ADC	R31,R19
    0050A 8020      LD	R2,Z
    0050B 8031      LDD	R3,Z+1
    0050C 2444      CLR	R4
    0050D 2455      CLR	R5
    0050E 8068      LD	R6,Y
    0050F 8079      LDD	R7,Y+1
    00510 808A      LDD	R8,Y+2
    00511 809B      LDD	R9,Y+3
    00512 0C62      ADD	R6,R2
    00513 1C73      ADC	R7,R3
    00514 1C84      ADC	R8,R4
    00515 1C95      ADC	R9,R5
    00516 8268      ST	Y,R6
    00517 8279      STD	Y+1,R7
    00518 828A      STD	Y+2,R8
    00519 829B      STD	Y+3,R9
(0221)   }
    0051A 5F4F      SUBI	R20,0xFF
    0051B 4F5F      SBCI	R21,0xFF
    0051C 1740      CP	R20,R16
    0051D 0751      CPC	R21,R17
    0051E F330      BCS	0x0505
(0222)   
(0223)   inAvg = inSum;   //inAvg = inSum*128/128;   //inAvg = inSum*2;  //inAvg = inSum*128/64;  min is about 344
    0051F 8028      LD	R2,Y
    00520 8039      LDD	R3,Y+1
    00521 804A      LDD	R4,Y+2
    00522 805B      LDD	R5,Y+3
    00523 822C      STD	Y+4,R2
    00524 823D      STD	Y+5,R3
    00525 824E      STD	Y+6,R4
    00526 825F      STD	Y+7,R5
(0224)   return inAvg;
    00527 810C      LDD	R16,Y+4
    00528 811D      LDD	R17,Y+5
    00529 812E      LDD	R18,Y+6
    0052A 813F      LDD	R19,Y+7
    0052B 9628      ADIW	R28,0x8
    0052C 940C 1222 JMP	pop_xgset300C
_materialDetect:
  ad_val_two           --> R10
  ad_val_one           --> R10
  disp_val             --> R10
  ad_temp              --> R12
  high_thresh          --> Y,+10
  low_thresh           --> Y,+6
  ad_val               --> R22
  ad_arr_sum           --> Y,+2
  temp_resp_time       --> R10
  i                    --> R20
    0052E 940E 1212 CALL	push_xgsetF0FC
    00530 972E      SBIW	R28,0xE
(0225) }
(0226) 
(0227) 
(0228) //detect material
(0229) void materialDetect(void)
(0230) {
(0231)   static u32 ad_sum = 0; 
(0232)   //static u16 ad_val = 0; 
(0233)   static u16 ad_cnt = 0; 
(0234)   static u8 temp = 0; 
(0235)   static u16 cnt = 0; 
(0236)   static u16 maxVal[128] = {0};  //2000/20=100
(0237)   //static u16 maxValTwo[128] = {0};
(0238)   u16 disp_val = 0; 
(0239)   u16 i = 0, ad_temp = 0;
    00531 2744      CLR	R20
    00532 2755      CLR	R21
    00533 24CC      CLR	R12
    00534 24DD      CLR	R13
(0240)   static u16 iTest = 0;
(0241)   static SEG_COLOR_ENUM dispColor = SEG_COLOR_GREEN;
(0242)   static s16 prev_val = 0;
(0243)   static u16 nThreeSec = 0;
(0244)   s16 ad_val = 0, ad_val_one = 0, ad_val_two = 0;
    00535 2766      CLR	R22
    00536 2777      CLR	R23
(0245)   u32 ad_arr_sum = 0;
    00537 E080      LDI	R24,0
    00538 838A      STD	Y+2,R24
    00539 838B      STD	Y+3,R24
    0053A 838C      STD	Y+4,R24
    0053B 838D      STD	Y+5,R24
(0246)   u16 temp_resp_time = 0;
    0053C 24AA      CLR	R10
    0053D 24BB      CLR	R11
(0247)   u32 high_thresh = 0, low_thresh = 0;
    0053E E080      LDI	R24,0
    0053F 878A      STD	Y+10,R24
    00540 878B      STD	Y+11,R24
    00541 878C      STD	Y+12,R24
    00542 878D      STD	Y+13,R24
    00543 E080      LDI	R24,0
    00544 838E      STD	Y+6,R24
    00545 838F      STD	Y+7,R24
    00546 8788      STD	Y+8,R24
    00547 8789      STD	Y+9,R24
(0248)   
(0249)   if(timer_1ms_flag)
    00548 9020 032C LDS	R2,timer_1ms_flag
    0054A 2022      TST	R2
    0054B F409      BNE	0x054D
    0054C C193      RJMP	0x06E0
(0250)   {
(0251)     timer_1ms_flag = FALSE;
    0054D 2422      CLR	R2
    0054E 9220 032C STS	timer_1ms_flag,R2
(0252) 	
(0253)   	if(PORT_KZ2_LOW_IN() == TRUE)
    00550 DF6B      RCALL	_PORT_KZ2_LOW_IN
    00551 3001      CPI	R16,1
    00552 F499      BNE	0x0566
(0254)   	{
(0255)   	  if(PORT_KZ1_HIGH_IN()==TRUE) //value is small
    00553 DF58      RCALL	_PORT_KZ1_HIGH_IN
    00554 3001      CPI	R16,1
    00555 F481      BNE	0x0566
(0256)   	  {
(0257)   	    //ad_temp = adc_start(AD_KZ1)*36 + 258;
(0258) 		//ad_temp = adc_start(AD_KZ1);  //changed to adc_start(AD_KZ1)+100, 20160124
(0259) 		ad_temp = adc_start(AD_KZ1) + 100;  //100 is offset
    00556 2700      CLR	R16
    00557 940E 0E8C CALL	_adc_start
    00559 0178      MOVW	R14,R16
    0055A 01C7      MOVW	R24,R14
    0055B 598C      SUBI	R24,0x9C
    0055C 4F9F      SBCI	R25,0xFF
    0055D 016C      MOVW	R12,R24
(0260) 		
(0261) 		//LedLight(LED_D2, ON);
(0262) 		
(0263)   	    getMaxVal(128, ad_temp, (u16*)&maxVal);
    0055E E78C      LDI	R24,0x7C
    0055F E090      LDI	R25,0
    00560 8399      STD	Y+1,R25
    00561 8388      ST	Y,R24
    00562 0196      MOVW	R18,R12
    00563 E800      LDI	R16,0x80
    00564 E010      LDI	R17,0
    00565 DF64      RCALL	_getMaxVal
(0264)   	  }
(0265)   	  else  //HIGH_IN is low, means value is big 
(0266)   	  {
(0267)   	    //ad_temp = adc_start(AD_KZ1)*54 + 258;     //(*3/2)*36
(0268)   		//getMaxVal(128, ad_temp, (u16*)&maxValOne);
(0269) 		
(0270) 		//LedLight(LED_D2, OFF);
(0271)   	  }
(0272)   	}
(0273) 	
(0274)   	/*for(i=0; i<32; i++)
(0275)   	{
(0276)   	maxValOne[i] = i;
(0277)   	maxValTwo[i] = 2*i;
(0278)   	}*/
(0279)   	
(0280)   	cnt += 1;
    00566 9180 007A LDS	R24,control.c:tickCnt+8
    00568 9190 007B LDS	R25,control.c:tickCnt+9
    0056A 9601      ADIW	R24,1
    0056B 9390 007B STS	control.c:tickCnt+9,R25
    0056D 9380 007A STS	control.c:tickCnt+8,R24
(0281)   	if(cnt >= 3000) //3000ms/20ms = 150 times
    0056F 3B88      CPI	R24,0xB8
    00570 E0EB      LDI	R30,0xB
    00571 079E      CPC	R25,R30
    00572 F408      BCC	0x0574
    00573 C16C      RJMP	0x06E0
(0282)   	{	
(0283)   	  cnt = 0; 
    00574 2422      CLR	R2
    00575 2433      CLR	R3
    00576 9230 007B STS	control.c:tickCnt+9,R3
    00578 9220 007A STS	control.c:tickCnt+8,R2
(0284)   	  ad_arr[nThreeSec] = getAvgVal(128, (u16*)&maxVal); 
    0057A E72C      LDI	R18,0x7C
    0057B E030      LDI	R19,0
    0057C E800      LDI	R16,0x80
    0057D E010      LDI	R17,0
    0057E DF74      RCALL	_getAvgVal
    0057F EE8D      LDI	R24,0xED
    00580 E091      LDI	R25,1
    00581 91E0 0181 LDS	R30,serv_prevState+15
    00583 91F0 0182 LDS	R31,serv_prevState+16
    00585 0FEE      LSL	R30
    00586 1FFF      ROL	R31
    00587 0FE8      ADD	R30,R24
    00588 1FF9      ADC	R31,R25
    00589 8311      STD	Z+1,R17
    0058A 8300      ST	Z,R16
(0285) 	  temp_resp_time = g_resp_time/3;
    0058B E023      LDI	R18,3
    0058C E030      LDI	R19,0
    0058D 9100 031E LDS	R16,g_resp_time
    0058F 9110 031F LDS	R17,g_resp_time+1
    00591 940E 1152 CALL	div16u
    00593 0158      MOVW	R10,R16
(0286) 	  
(0287) 	  if((nThreeSec<150) && (nThreeSec < temp_resp_time))   //3s*150=450
    00594 90C0 0181 LDS	R12,serv_prevState+15
    00596 90D0 0182 LDS	R13,serv_prevState+16
    00598 01C6      MOVW	R24,R12
    00599 3986      CPI	R24,0x96
    0059A E0E0      LDI	R30,0
    0059B 079E      CPC	R25,R30
    0059C F448      BCC	0x05A6
    0059D 158A      CP	R24,R10
    0059E 059B      CPC	R25,R11
    0059F F430      BCC	0x05A6
(0288) 	  {
(0289) 	    nThreeSec++;
    005A0 9601      ADIW	R24,1
    005A1 9390 0182 STS	serv_prevState+16,R25
    005A3 9380 0181 STS	serv_prevState+15,R24
(0290) 	  }
    005A5 C006      RJMP	0x05AC
(0291) 	  else
(0292) 	  {
(0293) 	    nThreeSec = 0;
    005A6 2422      CLR	R2
    005A7 2433      CLR	R3
    005A8 9230 0182 STS	serv_prevState+16,R3
    005AA 9220 0181 STS	serv_prevState+15,R2
(0294) 	  }  
(0295) 	  
(0296) 	  for(i=0; i<temp_resp_time; i++)
    005AC 2744      CLR	R20
    005AD 2755      CLR	R21
    005AE C01D      RJMP	0x05CC
(0297) 	  {
(0298) 	    ad_arr_sum += ad_arr[i];
    005AF EE8D      LDI	R24,0xED
    005B0 E091      LDI	R25,1
    005B1 01FA      MOVW	R30,R20
    005B2 0FEE      LSL	R30
    005B3 1FFF      ROL	R31
    005B4 0FE8      ADD	R30,R24
    005B5 1FF9      ADC	R31,R25
    005B6 8020      LD	R2,Z
    005B7 8031      LDD	R3,Z+1
    005B8 2444      CLR	R4
    005B9 FC37      SBRC	R3,7
    005BA 9440      COM	R4
    005BB 2455      CLR	R5
    005BC FC47      SBRC	R4,7
    005BD 9450      COM	R5
    005BE 806A      LDD	R6,Y+2
    005BF 807B      LDD	R7,Y+3
    005C0 808C      LDD	R8,Y+4
    005C1 809D      LDD	R9,Y+5
    005C2 0C62      ADD	R6,R2
    005C3 1C73      ADC	R7,R3
    005C4 1C84      ADC	R8,R4
    005C5 1C95      ADC	R9,R5
    005C6 826A      STD	Y+2,R6
    005C7 827B      STD	Y+3,R7
    005C8 828C      STD	Y+4,R8
    005C9 829D      STD	Y+5,R9
(0299) 	  }
    005CA 5F4F      SUBI	R20,0xFF
    005CB 4F5F      SBCI	R21,0xFF
    005CC 154A      CP	R20,R10
    005CD 055B      CPC	R21,R11
    005CE F300      BCS	0x05AF
(0300) 	  
(0301) 	  //Seg_164_Number(ad_arr_sum, dispColor, MARK_NULL);
(0302) 	  
(0303) 	  ad_val = ad_arr_sum/temp_resp_time;
    005CF 0115      MOVW	R2,R10
    005D0 2444      CLR	R4
    005D1 2455      CLR	R5
    005D2 810A      LDD	R16,Y+2
    005D3 811B      LDD	R17,Y+3
    005D4 812C      LDD	R18,Y+4
    005D5 813D      LDD	R19,Y+5
    005D6 925A      ST	-Y,R5
    005D7 924A      ST	-Y,R4
    005D8 923A      ST	-Y,R3
    005D9 922A      ST	-Y,R2
    005DA 940E 116C CALL	div32u
    005DC 01B8      MOVW	R22,R16
(0304) 	  ad_arr_sum = 0;
    005DD E080      LDI	R24,0
    005DE 838A      STD	Y+2,R24
    005DF 838B      STD	Y+3,R24
    005E0 838C      STD	Y+4,R24
    005E1 838D      STD	Y+5,R24
(0305) 	  Seg_164_Number(ad_val, dispColor, MARK_NULL);
    005E2 E082      LDI	R24,2
    005E3 8388      ST	Y,R24
    005E4 9120 017E LDS	R18,serv_prevState+12
    005E6 940E 104F CALL	_Seg_164_Number
(0306) 	  
(0307)   	  /*if(ad_val_one > ad_val_two)
(0308)   	  {
(0309)   	    ad_val = ad_val_one;
(0310)   		LedLight(LED_D1, OFF);
(0311)   	  }
(0312)   	  else
(0313)   	  {
(0314)   	    ad_val = ad_val_two;
(0315)   		LedLight(LED_D1, ON);
(0316)   	  }*/
(0317)   	   
(0318)   	  if(prev_val < 10)
    005E8 9180 017F LDS	R24,serv_prevState+13
    005EA 9190 0180 LDS	R25,serv_prevState+14
    005EC 308A      CPI	R24,0xA
    005ED E0E0      LDI	R30,0
    005EE 079E      CPC	R25,R30
    005EF F42C      BGE	0x05F5
(0319)   	  {
(0320)   	      prev_val = ad_val;  //the first time
    005F0 9370 0180 STS	serv_prevState+14,R23
    005F2 9360 017F STS	serv_prevState+13,R22
(0321)   	  }
    005F4 C065      RJMP	0x065A
(0322)   	  else if(prev_val - ad_val > 1000)  //C编译器有问题，u16 - u16 结果如果为负，会被转成正数
    005F5 9020 017F LDS	R2,serv_prevState+13
    005F7 9030 0180 LDS	R3,serv_prevState+14
    005F9 1A26      SUB	R2,R22
    005FA 0A37      SBC	R3,R23
    005FB EE88      LDI	R24,0xE8
    005FC E093      LDI	R25,3
    005FD 1582      CP	R24,R2
    005FE 0593      CPC	R25,R3
    005FF F43C      BGE	0x0607
(0323)   	  {
(0324)   	    ad_val = prev_val - 1000;
    00600 9160 017F LDS	R22,serv_prevState+13
    00602 9170 0180 LDS	R23,serv_prevState+14
    00604 5E68      SUBI	R22,0xE8
    00605 4073      SBCI	R23,3
(0325)   	  }	
    00606 C053      RJMP	0x065A
(0326)   	  else if(prev_val - ad_val > 100)
    00607 9020 017F LDS	R2,serv_prevState+13
    00609 9030 0180 LDS	R3,serv_prevState+14
    0060B 1A26      SUB	R2,R22
    0060C 0A37      SBC	R3,R23
    0060D E684      LDI	R24,0x64
    0060E E090      LDI	R25,0
    0060F 1582      CP	R24,R2
    00610 0593      CPC	R25,R3
    00611 F43C      BGE	0x0619
(0327)   	  {
(0328)   	    ad_val = prev_val - 100;
    00612 9160 017F LDS	R22,serv_prevState+13
    00614 9170 0180 LDS	R23,serv_prevState+14
    00616 5664      SUBI	R22,0x64
    00617 4070      SBCI	R23,0
(0329)   	  }
    00618 C041      RJMP	0x065A
(0330)   	  else if(prev_val - ad_val > 10)
    00619 9020 017F LDS	R2,serv_prevState+13
    0061B 9030 0180 LDS	R3,serv_prevState+14
    0061D 1A26      SUB	R2,R22
    0061E 0A37      SBC	R3,R23
    0061F E08A      LDI	R24,0xA
    00620 E090      LDI	R25,0
    00621 1582      CP	R24,R2
    00622 0593      CPC	R25,R3
    00623 F43C      BGE	0x062B
(0331)   	  {
(0332)   	    ad_val = prev_val - 10;
    00624 9160 017F LDS	R22,serv_prevState+13
    00626 9170 0180 LDS	R23,serv_prevState+14
    00628 506A      SUBI	R22,0xA
    00629 4070      SBCI	R23,0
(0333)   	  }
    0062A C02F      RJMP	0x065A
(0334)   	  else if(ad_val - prev_val > 1000)
    0062B 9020 017F LDS	R2,serv_prevState+13
    0062D 9030 0180 LDS	R3,serv_prevState+14
    0062F 012B      MOVW	R4,R22
    00630 1842      SUB	R4,R2
    00631 0853      SBC	R5,R3
    00632 EE88      LDI	R24,0xE8
    00633 E093      LDI	R25,3
    00634 1584      CP	R24,R4
    00635 0595      CPC	R25,R5
    00636 F424      BGE	0x063B
(0335)   	  {
(0336)   	    ad_val = prev_val + 1000;
    00637 01B1      MOVW	R22,R2
    00638 5168      SUBI	R22,0x18
    00639 4F7C      SBCI	R23,0xFC
(0337)   	  }
    0063A C01F      RJMP	0x065A
(0338)   	  else if(ad_val - prev_val > 100)
    0063B 9020 017F LDS	R2,serv_prevState+13
    0063D 9030 0180 LDS	R3,serv_prevState+14
    0063F 012B      MOVW	R4,R22
    00640 1842      SUB	R4,R2
    00641 0853      SBC	R5,R3
    00642 E684      LDI	R24,0x64
    00643 E090      LDI	R25,0
    00644 1584      CP	R24,R4
    00645 0595      CPC	R25,R5
    00646 F424      BGE	0x064B
(0339)   	  {
(0340)   	    ad_val = prev_val + 100;
    00647 01B1      MOVW	R22,R2
    00648 596C      SUBI	R22,0x9C
    00649 4F7F      SBCI	R23,0xFF
(0341)   	  }
    0064A C00F      RJMP	0x065A
(0342)   	  else if(ad_val - prev_val > 10)
    0064B 9020 017F LDS	R2,serv_prevState+13
    0064D 9030 0180 LDS	R3,serv_prevState+14
    0064F 012B      MOVW	R4,R22
    00650 1842      SUB	R4,R2
    00651 0853      SBC	R5,R3
    00652 E08A      LDI	R24,0xA
    00653 E090      LDI	R25,0
    00654 1584      CP	R24,R4
    00655 0595      CPC	R25,R5
    00656 F41C      BGE	0x065A
(0343)   	  {
(0344)   	  	ad_val = prev_val + 10;
    00657 01B1      MOVW	R22,R2
    00658 5F66      SUBI	R22,0xF6
    00659 4F7F      SBCI	R23,0xFF
(0345)   	  }
(0346)   	  
(0347)   	  high_thresh = g_mt_empty + (g_mt_full - g_mt_empty)*g_per_high/100;
    0065A 90A0 0324 LDS	R10,g_mt_empty
    0065C 90B0 0325 LDS	R11,g_mt_empty+1
    0065E 9100 0326 LDS	R16,g_mt_full
    00660 9110 0327 LDS	R17,g_mt_full+1
    00662 190A      SUB	R16,R10
    00663 091B      SBC	R17,R11
    00664 9120 0322 LDS	R18,g_per_high
    00666 9130 0323 LDS	R19,g_per_high+1
    00668 940E 11EE CALL	empy16s
    0066A E624      LDI	R18,0x64
    0066B E030      LDI	R19,0
    0066C 940E 1152 CALL	div16u
    0066E 0115      MOVW	R2,R10
    0066F 0E20      ADD	R2,R16
    00670 1E31      ADC	R3,R17
    00671 2444      CLR	R4
    00672 2455      CLR	R5
    00673 862A      STD	Y+10,R2
    00674 863B      STD	Y+11,R3
    00675 864C      STD	Y+12,R4
    00676 865D      STD	Y+13,R5
(0348) 	  low_thresh = g_mt_empty +(g_mt_full - g_mt_empty)*g_per_low/100;
    00677 90A0 0324 LDS	R10,g_mt_empty
    00679 90B0 0325 LDS	R11,g_mt_empty+1
    0067B 9100 0326 LDS	R16,g_mt_full
    0067D 9110 0327 LDS	R17,g_mt_full+1
    0067F 190A      SUB	R16,R10
    00680 091B      SBC	R17,R11
    00681 9120 0320 LDS	R18,g_per_low
    00683 9130 0321 LDS	R19,g_per_low+1
    00685 940E 11EE CALL	empy16s
    00687 E624      LDI	R18,0x64
    00688 E030      LDI	R19,0
    00689 940E 1152 CALL	div16u
    0068B 0115      MOVW	R2,R10
    0068C 0E20      ADD	R2,R16
    0068D 1E31      ADC	R3,R17
    0068E 2444      CLR	R4
    0068F 2455      CLR	R5
    00690 822E      STD	Y+6,R2
    00691 823F      STD	Y+7,R3
    00692 8648      STD	Y+8,R4
    00693 8659      STD	Y+9,R5
(0349) 
(0350)   	  if(ad_val < low_thresh)
    00694 802E      LDD	R2,Y+6
    00695 803F      LDD	R3,Y+7
    00696 8448      LDD	R4,Y+8
    00697 8459      LDD	R5,Y+9
    00698 013B      MOVW	R6,R22
    00699 2488      CLR	R8
    0069A FC77      SBRC	R7,7
    0069B 9480      COM	R8
    0069C 2499      CLR	R9
    0069D FC87      SBRC	R8,7
    0069E 9490      COM	R9
    0069F 1462      CP	R6,R2
    006A0 0473      CPC	R7,R3
    006A1 0484      CPC	R8,R4
    006A2 0495      CPC	R9,R5
    006A3 F438      BCC	0x06AB
(0351)   	  {
(0352)         dispColor = SEG_COLOR_GREEN;
    006A4 E081      LDI	R24,1
    006A5 9380 017E STS	serv_prevState+12,R24
(0353)   		module_state = MODULE_STATE_WORK_NORM;
    006A7 E082      LDI	R24,2
    006A8 9380 01EB STS	module_state,R24
(0354)   	  }
    006AA C016      RJMP	0x06C1
(0355)   	  else if(ad_val > high_thresh)
    006AB 842A      LDD	R2,Y+10
    006AC 843B      LDD	R3,Y+11
    006AD 844C      LDD	R4,Y+12
    006AE 845D      LDD	R5,Y+13
    006AF 013B      MOVW	R6,R22
    006B0 2488      CLR	R8
    006B1 FC77      SBRC	R7,7
    006B2 9480      COM	R8
    006B3 2499      CLR	R9
    006B4 FC87      SBRC	R8,7
    006B5 9490      COM	R9
    006B6 1426      CP	R2,R6
    006B7 0437      CPC	R3,R7
    006B8 0448      CPC	R4,R8
    006B9 0459      CPC	R5,R9
    006BA F430      BCC	0x06C1
(0356)   	  {
(0357)         dispColor = SEG_COLOR_RED;
    006BB 2422      CLR	R2
    006BC 9220 017E STS	serv_prevState+12,R2
(0358)         module_state = MODULE_STATE_WORK_WARN;
    006BE E083      LDI	R24,3
    006BF 9380 01EB STS	module_state,R24
(0359)   	  }
(0360)   	  
(0361) 	  	//LedLight(LED_D1, ON);
(0362)         //LedLight(LED_D2, OFF);
(0363) 		//Per_Dly_Ms(5000);
(0364) 		
(0365)   	  //Seg_164_Number(ad_val, dispColor, MARK_NULL);
(0366)   	  
(0367)   	  prev_val = ad_val;
    006C1 9370 0180 STS	serv_prevState+14,R23
    006C3 9360 017F STS	serv_prevState+13,R22
(0368)   	  
(0369)   	  for(i=0; i<128; i++)
    006C5 2744      CLR	R20
    006C6 2755      CLR	R21
    006C7 C00D      RJMP	0x06D5
(0370)   	  {
(0371)   	    maxVal[i] = 0;
    006C8 E78C      LDI	R24,0x7C
    006C9 E090      LDI	R25,0
    006CA 01FA      MOVW	R30,R20
    006CB 0FEE      LSL	R30
    006CC 1FFF      ROL	R31
    006CD 0FE8      ADD	R30,R24
    006CE 1FF9      ADC	R31,R25
    006CF 2422      CLR	R2
    006D0 2433      CLR	R3
    006D1 8231      STD	Z+1,R3
    006D2 8220      ST	Z,R2
(0372)   	  }
    006D3 5F4F      SUBI	R20,0xFF
    006D4 4F5F      SBCI	R21,0xFF
    006D5 3840      CPI	R20,0x80
    006D6 E0E0      LDI	R30,0
    006D7 075E      CPC	R21,R30
    006D8 F378      BCS	0x06C8
(0373)   	  
(0374)   	  temp++;
    006D9 9180 0079 LDS	R24,control.c:tickCnt+7
    006DB 5F8F      SUBI	R24,0xFF
    006DC 9380 0079 STS	control.c:tickCnt+7,R24
(0375)   	  if(temp < 5)
    006DE 3085      CPI	R24,5
    006DF F400      BCC	0x06E0
(0376)   	  {
(0377)   	     //temp = 0;
(0378)   		 //Seg_164_Number(ad_val_one, dispColor, MARK_NULL);
(0379)   		 //LedLight(LED_D2, ON);
(0380)   	  }
(0381)   	  else 
(0382)   	  {
(0383)   	     //if(temp > 10) temp = 0;
(0384)   		 //Seg_164_Number(ad_val_two, dispColor, MARK_NULL);
(0385)   		 //LedLight(LED_D2, OFF);
(0386)   	  }
(0387)     }
(0388)   }
    006E0 962E      ADIW	R28,0xE
    006E1 940C 1207 JMP	pop_xgsetF0FC
_buttonDetect:
  temp_disp_code       --> R20
    006E3 940E 1227 CALL	push_xgsetF000
    006E5 9722      SBIW	R28,2
(0389) }
(0390)   
(0391)   
(0392) void buttonDetect(void)
(0393) {
(0394)   static SERV_STATE_ENUM serv_state = SERV_STATE_MIN;
(0395)   static SERV_STATE_ENUM serv_prevState = SERV_STATE_MIN;
(0396)   u8 temp_disp_code = 0;
    006E6 2744      CLR	R20
(0397) 
(0398)   if(module_quit_flag == TRUE)
    006E7 9180 01CE LDS	R24,module_quit_flag
    006E9 3081      CPI	R24,1
    006EA F439      BNE	0x06F2
(0399)   {
(0400)   	module_state = MODULE_STATE_QUIT;
    006EB E087      LDI	R24,7
    006EC 9380 01EB STS	module_state,R24
(0401) 	serv_state = SERV_STATE_MIN;;
    006EE 2422      CLR	R2
    006EF 9220 0183 STS	serv_prevState+17,R2
(0402) 	return;
    006F1 C591      RJMP	0x0C83
(0403)   }
(0404)   
(0405)   if((button[1].heldFlag == TRUE)&&(button[0].heldFlag == TRUE))
    006F2 9180 006D LDS	R24,maxVal+3
    006F4 3081      CPI	R24,1
    006F5 F481      BNE	0x0706
    006F6 9180 0065 LDS	R24,ad_cnt
    006F8 3081      CPI	R24,1
    006F9 F461      BNE	0x0706
(0406)   {
(0407)     button[1].heldFlag = FALSE;
    006FA 2422      CLR	R2
    006FB 9220 006D STS	maxVal+3,R2
(0408) 	button[0].heldFlag = FALSE;
    006FD 9220 0065 STS	ad_cnt,R2
(0409) 
(0410) 	module_state = MODULE_STATE_SERVICE;
    006FF E085      LDI	R24,5
    00700 9380 01EB STS	module_state,R24
(0411)     serv_state = SERV_STATE_RESET;
    00702 E081      LDI	R24,1
    00703 9380 0183 STS	serv_prevState+17,R24
(0412)   }
    00705 C06B      RJMP	0x0771
(0413)   else if((button[1].heldFlag == TRUE) && (button[0].pressedFlag == FALSE))
    00706 9180 006D LDS	R24,maxVal+3
    00708 3081      CPI	R24,1
    00709 F471      BNE	0x0718
    0070A 9020 0066 LDS	R2,ad_cnt+1
    0070C 2022      TST	R2
    0070D F451      BNE	0x0718
(0414)   {
(0415)     button[1].heldFlag = FALSE;
    0070E 2422      CLR	R2
    0070F 9220 006D STS	maxVal+3,R2
(0416) 	module_state = MODULE_STATE_SERVICE;
    00711 E085      LDI	R24,5
    00712 9380 01EB STS	module_state,R24
(0417)     serv_state = SERV_STATE_CODE_CHANGE;
    00714 E083      LDI	R24,3
    00715 9380 0183 STS	serv_prevState+17,R24
(0418) 	//LedLight(LED_D2, ON);
(0419) 	//LedLight(LED_D1, OFF);
(0420)   }
    00717 C059      RJMP	0x0771
(0421)   else if((button[0].heldFlag == TRUE) && (button[1].pressedFlag == FALSE))
    00718 9180 0065 LDS	R24,ad_cnt
    0071A 3081      CPI	R24,1
    0071B F469      BNE	0x0729
    0071C 9020 006E LDS	R2,maxVal+4
    0071E 2022      TST	R2
    0071F F449      BNE	0x0729
(0422)   {
(0423)     button[0].heldFlag = FALSE;
    00720 2422      CLR	R2
    00721 9220 0065 STS	ad_cnt,R2
(0424) 	module_state = MODULE_STATE_SERVICE;
    00723 E085      LDI	R24,5
    00724 9380 01EB STS	module_state,R24
(0425)     serv_state = SERV_STATE_PARA_CHANGE;
    00726 9380 0183 STS	serv_prevState+17,R24
(0426) 	//LedLight(LED_D1, ON);
(0427) 	//LedLight(LED_D2, OFF);
(0428)   }
    00728 C048      RJMP	0x0771
(0429)   else if(button[1].releasedFlag == TRUE)
    00729 9180 006F LDS	R24,maxVal+5
    0072B 3081      CPI	R24,1
    0072C F519      BNE	0x0750
(0430)   {
(0431)     button[1].releasedFlag = FALSE;   //JP2
    0072D 2422      CLR	R2
    0072E 9220 006F STS	maxVal+5,R2
(0432) 	  timer_3s_cnt = 0;
    00730 2433      CLR	R3
    00731 9230 01CC STS	timer_3s_cnt+1,R3
    00733 9220 01CB STS	timer_3s_cnt,R2
(0433)     timer_3s_flag = FALSE;
    00735 9220 01CD STS	timer_3s_flag,R2
(0434) 	  module_prevState = module_state;
    00737 9020 01EB LDS	R2,module_state
    00739 9220 01EC STS	module_prevState,R2
(0435)     module_state = MODULE_STATE_SERVICE;
    0073B E085      LDI	R24,5
    0073C 9380 01EB STS	module_state,R24
(0436) 	  g_disp_code++;
    0073E 9180 0319 LDS	R24,g_disp_code
    00740 5F8F      SUBI	R24,0xFF
    00741 9380 0319 STS	g_disp_code,R24
(0437)   	if((g_disp_code >= DISP_CODE_MAX) || (g_disp_code <= DISP_CODE_MIN))
    00743 2E28      MOV	R2,R24
    00744 308A      CPI	R24,0xA
    00745 F418      BCC	0x0749
    00746 E080      LDI	R24,0
    00747 1582      CP	R24,R2
    00748 F018      BCS	0x074C
(0438)   	{
(0439)   	  g_disp_code = DISP_CODE_0;
    00749 E081      LDI	R24,1
    0074A 9380 0319 STS	g_disp_code,R24
(0440)   	}
(0441)     serv_state = SERV_STATE_DISP_CODE;   //JP2
    0074C E082      LDI	R24,2
    0074D 9380 0183 STS	serv_prevState+17,R24
(0442)   }
    0074F C021      RJMP	0x0771
(0443)   else if(button[0].releasedFlag == TRUE)
    00750 9180 0067 LDS	R24,temp
    00752 3081      CPI	R24,1
    00753 F4C9      BNE	0x076D
(0444)   {
(0445)     button[0].releasedFlag = FALSE;   //JP1
    00754 2422      CLR	R2
    00755 9220 0067 STS	temp,R2
(0446)     timer_3s_cnt = 0;
    00757 2433      CLR	R3
    00758 9230 01CC STS	timer_3s_cnt+1,R3
    0075A 9220 01CB STS	timer_3s_cnt,R2
(0447)     timer_3s_flag = FALSE;
    0075C 9220 01CD STS	timer_3s_flag,R2
(0448) 
(0449) 	module_state = MODULE_STATE_SERVICE;
    0075E E085      LDI	R24,5
    0075F 9380 01EB STS	module_state,R24
(0450) 	if(serv_prevState == SERV_STATE_PARA_CHANGE)
    00761 9180 0184 LDS	R24,serv_prevState+18
    00763 3085      CPI	R24,5
    00764 F421      BNE	0x0769
(0451) 	{
(0452) 	  //LedLight(LED_D2, ON);
(0453) 	  //LedLight(LED_D1, OFF);
(0454) 	  serv_state = SERV_STATE_PARA_SAVE;   //JP1
    00765 E086      LDI	R24,6
    00766 9380 0183 STS	serv_prevState+17,R24
(0455) 	}
    00768 C008      RJMP	0x0771
(0456) 	else
(0457) 	{ //LedLight(LED_D1, ON);
(0458) 	  //LedLight(LED_D2, OFF);
(0459) 	  serv_state = SERV_STATE_DISP_PARA;   //JP1
    00769 E084      LDI	R24,4
    0076A 9380 0183 STS	serv_prevState+17,R24
(0460) 	}
(0461)   }
    0076C C004      RJMP	0x0771
(0462)   else
(0463)   {
(0464)     //serv_state = SERV_STATE_MIN; 
(0465) 	//timer_3s_cnt = 0;
(0466)     //timer_3s_flag = FALSE;
(0467) 	LedLight(LED_D2, OFF);
    0076D 2722      CLR	R18
    0076E E002      LDI	R16,2
    0076F 940E 0D37 CALL	_LedLight
(0468) 	//LedLight(LED_D1, OFF);
(0469) 	//Per_Dly_Ms(2000);
(0470)   }
(0471) 
(0472)   switch(serv_state)
    00771 9160 0183 LDS	R22,serv_prevState+17
    00773 2777      CLR	R23
    00774 3061      CPI	R22,1
    00775 E0E0      LDI	R30,0
    00776 077E      CPC	R23,R30
    00777 F0D1      BEQ	0x0792
    00778 3062      CPI	R22,2
    00779 E0E0      LDI	R30,0
    0077A 077E      CPC	R23,R30
    0077B F409      BNE	0x077D
    0077C C08C      RJMP	0x0809
    0077D 3063      CPI	R22,3
    0077E E0E0      LDI	R30,0
    0077F 077E      CPC	R23,R30
    00780 F409      BNE	0x0782
    00781 C0AF      RJMP	0x0831
    00782 3064      CPI	R22,4
    00783 E0E0      LDI	R30,0
    00784 077E      CPC	R23,R30
    00785 F409      BNE	0x0787
    00786 C0C3      RJMP	0x084A
    00787 3065      CPI	R22,5
    00788 E0E0      LDI	R30,0
    00789 077E      CPC	R23,R30
    0078A F409      BNE	0x078C
    0078B C1E3      RJMP	0x096F
    0078C 3066      CPI	R22,6
    0078D E0E0      LDI	R30,0
    0078E 077E      CPC	R23,R30
    0078F F409      BNE	0x0791
    00790 C3B0      RJMP	0x0B41
    00791 C4F1      RJMP	0x0C83
(0473)   {
(0474)     case SERV_STATE_RESET:
(0475)       me_mt_full.highByte = MT_FULL/100;
    00792 E086      LDI	R24,6
    00793 9380 01D7 STS	me_mt_full,R24
(0476)       me_mt_full.lowByte = MT_FULL%100;
    00795 2422      CLR	R2
    00796 9220 01D8 STS	me_mt_full+1,R2
(0477)       EEPROM_Write_Bytes(MT_FULL_ADDR, &me_mt_full.highByte, 2);
    00798 E082      LDI	R24,2
    00799 E090      LDI	R25,0
    0079A 8399      STD	Y+1,R25
    0079B 8388      ST	Y,R24
    0079C ED27      LDI	R18,0xD7
    0079D E031      LDI	R19,1
    0079E E200      LDI	R16,0x20
    0079F E010      LDI	R17,0
    007A0 940E 0E0D CALL	_EEPROM_Write_Bytes
(0478)       me_mt_empty.highByte = MT_EMPTY/100;
    007A2 E084      LDI	R24,4
    007A3 9380 01D9 STS	me_mt_empty,R24
(0479)       me_mt_empty.lowByte = MT_EMPTY%100;
    007A5 2422      CLR	R2
    007A6 9220 01DA STS	me_mt_empty+1,R2
(0480)       EEPROM_Write_Bytes(MT_EMPTY_ADDR, &me_mt_empty.highByte, 2);
    007A8 E082      LDI	R24,2
    007A9 E090      LDI	R25,0
    007AA 8399      STD	Y+1,R25
    007AB 8388      ST	Y,R24
    007AC ED29      LDI	R18,0xD9
    007AD E031      LDI	R19,1
    007AE E208      LDI	R16,0x28
    007AF E010      LDI	R17,0
    007B0 940E 0E0D CALL	_EEPROM_Write_Bytes
(0481) 	  
(0482) 	  me_per_high.highByte = PER_HIGH/100;
    007B2 2422      CLR	R2
    007B3 9220 01DB STS	me_per_high,R2
(0483)       me_per_high.lowByte = PER_HIGH%100;
    007B5 E580      LDI	R24,0x50
    007B6 9380 01DC STS	me_per_high+1,R24
(0484)       EEPROM_Write_Bytes(PER_HIGH_ADDR, &me_per_high.highByte, 2);
    007B8 E082      LDI	R24,2
    007B9 E090      LDI	R25,0
    007BA 8399      STD	Y+1,R25
    007BB 8388      ST	Y,R24
    007BC ED2B      LDI	R18,0xDB
    007BD E031      LDI	R19,1
    007BE E300      LDI	R16,0x30
    007BF E010      LDI	R17,0
    007C0 940E 0E0D CALL	_EEPROM_Write_Bytes
(0485)       me_per_low.highByte = PER_LOW/100;
    007C2 2422      CLR	R2
    007C3 9220 01DD STS	me_per_low,R2
(0486)       me_per_low.lowByte = PER_LOW%100;
    007C5 E184      LDI	R24,0x14
    007C6 9380 01DE STS	me_per_low+1,R24
(0487)       EEPROM_Write_Bytes(PER_LOW_ADDR, &me_per_low.highByte, 2);
    007C8 E082      LDI	R24,2
    007C9 E090      LDI	R25,0
    007CA 8399      STD	Y+1,R25
    007CB 8388      ST	Y,R24
    007CC ED2D      LDI	R18,0xDD
    007CD E031      LDI	R19,1
    007CE E308      LDI	R16,0x38
    007CF E010      LDI	R17,0
    007D0 940E 0E0D CALL	_EEPROM_Write_Bytes
(0488) 	  
(0489) 	  me_resp_time.highByte = RESP_TIME_VALUE/100;
    007D2 2422      CLR	R2
    007D3 9220 01DF STS	me_resp_time,R2
(0490)       me_resp_time.lowByte = RESP_TIME_VALUE%100;
    007D5 E083      LDI	R24,3
    007D6 9380 01E0 STS	me_resp_time+1,R24
(0491)       EEPROM_Write_Bytes(RESP_TIME_ADDR, &me_resp_time.highByte, 2);
    007D8 E082      LDI	R24,2
    007D9 E090      LDI	R25,0
    007DA 8399      STD	Y+1,R25
    007DB 8388      ST	Y,R24
    007DC ED2F      LDI	R18,0xDF
    007DD E031      LDI	R19,1
    007DE E400      LDI	R16,0x40
    007DF E010      LDI	R17,0
    007E0 940E 0E0D CALL	_EEPROM_Write_Bytes
(0492) 	  
(0493)       me_hv_value.highByte = HV_800V_VALUE/100;
    007E2 E083      LDI	R24,3
    007E3 9380 01E1 STS	me_hv_value,R24
(0494)       me_hv_value.lowByte = HV_800V_VALUE%100;
    007E5 2422      CLR	R2
    007E6 9220 01E2 STS	me_hv_value+1,R2
(0495)       EEPROM_Write_Bytes(HV_800V_ADDR, &me_hv_value.highByte, 2);
    007E8 E082      LDI	R24,2
    007E9 E090      LDI	R25,0
    007EA 8399      STD	Y+1,R25
    007EB 8388      ST	Y,R24
    007EC EE21      LDI	R18,0xE1
    007ED E031      LDI	R19,1
    007EE E600      LDI	R16,0x60
    007EF E010      LDI	R17,0
    007F0 940E 0E0D CALL	_EEPROM_Write_Bytes
(0496) 	  
(0497) 	  me_addr_code.highByte = ADDR_CODE_VALUE/100;
    007F2 E08A      LDI	R24,0xA
    007F3 9380 01D5 STS	me_addr_code,R24
(0498) 	  me_addr_code.lowByte = ADDR_CODE_VALUE%100;
    007F5 2422      CLR	R2
    007F6 9220 01D6 STS	me_addr_code+1,R2
(0499) 	  EEPROM_Write_Bytes(ADDR_CODE_ADDR, &me_addr_code.highByte, 2);
    007F8 E082      LDI	R24,2
    007F9 E090      LDI	R25,0
    007FA 8399      STD	Y+1,R25
    007FB 8388      ST	Y,R24
    007FC ED25      LDI	R18,0xD5
    007FD E031      LDI	R19,1
    007FE E100      LDI	R16,0x10
    007FF E010      LDI	R17,0
    00800 940E 0E0D CALL	_EEPROM_Write_Bytes
(0500) 	  
(0501) 	  serv_state = SERV_STATE_MIN;
    00802 2422      CLR	R2
    00803 9220 0183 STS	serv_prevState+17,R2
(0502) 	  module_quit_flag = TRUE;
    00805 E081      LDI	R24,1
    00806 9380 01CE STS	module_quit_flag,R24
(0503)       break;
    00808 C47A      RJMP	0x0C83
(0504)   
(0505)     case SERV_STATE_DISP_CODE:	
(0506)       if(timer_3s_cnt == 0) 
    00809 9020 01CB LDS	R2,timer_3s_cnt
    0080B 9030 01CC LDS	R3,timer_3s_cnt+1
    0080D 2022      TST	R2
    0080E F441      BNE	0x0817
    0080F 2033      TST	R3
    00810 F431      BNE	0x0817
(0507)       {
(0508)         timer_3s_cnt++;
    00811 01C1      MOVW	R24,R2
    00812 9601      ADIW	R24,1
    00813 9390 01CC STS	timer_3s_cnt+1,R25
    00815 9380 01CB STS	timer_3s_cnt,R24
(0509)       }
(0510)       if(timer_3s_flag == TRUE)
    00817 9180 01CD LDS	R24,timer_3s_flag
    00819 3081      CPI	R24,1
    0081A F459      BNE	0x0826
(0511)       {
(0512)         timer_3s_flag = FALSE;
    0081B 2422      CLR	R2
    0081C 9220 01CD STS	timer_3s_flag,R2
(0513)         timer_3s_cnt = 0;
    0081E 2433      CLR	R3
    0081F 9230 01CC STS	timer_3s_cnt+1,R3
    00821 9220 01CB STS	timer_3s_cnt,R2
(0514)         serv_state = SERV_STATE_DISP_PARA;
    00823 E084      LDI	R24,4
    00824 9380 0183 STS	serv_prevState+17,R24
(0515)       }
(0516)       temp_disp_code = g_disp_code - 1;
    00826 9140 0319 LDS	R20,g_disp_code
    00828 5041      SUBI	R20,1
(0517)       Seg_164_Number(temp_disp_code, SEG_COLOR_GREEN, MARK_NULL);
    00829 E082      LDI	R24,2
    0082A 8388      ST	Y,R24
    0082B E021      LDI	R18,1
    0082C 2F04      MOV	R16,R20
    0082D 2711      CLR	R17
    0082E 940E 104F CALL	_Seg_164_Number
(0518)       break;
    00830 C452      RJMP	0x0C83
(0519) 	  
(0520)     case SERV_STATE_CODE_CHANGE:	 
(0521)       g_disp_code++;
    00831 9180 0319 LDS	R24,g_disp_code
    00833 5F8F      SUBI	R24,0xFF
    00834 9380 0319 STS	g_disp_code,R24
(0522)       if((g_disp_code >= DISP_CODE_MAX) || (g_disp_code <= DISP_CODE_MIN))
    00836 2E28      MOV	R2,R24
    00837 308A      CPI	R24,0xA
    00838 F418      BCC	0x083C
    00839 E080      LDI	R24,0
    0083A 1582      CP	R24,R2
    0083B F018      BCS	0x083F
(0523)       {
(0524)         g_disp_code = DISP_CODE_0;
    0083C E081      LDI	R24,1
    0083D 9380 0319 STS	g_disp_code,R24
(0525)       }
(0526) 	
(0527) 	  temp_disp_code = g_disp_code - 1;
    0083F 9140 0319 LDS	R20,g_disp_code
    00841 5041      SUBI	R20,1
(0528)       Seg_164_Number(temp_disp_code, SEG_COLOR_GREEN, MARK_NULL);
    00842 E082      LDI	R24,2
    00843 8388      ST	Y,R24
    00844 E021      LDI	R18,1
    00845 2F04      MOV	R16,R20
    00846 2711      CLR	R17
    00847 940E 104F CALL	_Seg_164_Number
(0529)       break;
    00849 C439      RJMP	0x0C83
(0530)   
(0531)     case SERV_STATE_DISP_PARA:	
(0532) 	  switch(g_disp_code)
    0084A 9140 0319 LDS	R20,g_disp_code
    0084C 2755      CLR	R21
    0084D 3041      CPI	R20,1
    0084E E0E0      LDI	R30,0
    0084F 075E      CPC	R21,R30
    00850 F149      BEQ	0x087A
    00851 3042      CPI	R20,2
    00852 E0E0      LDI	R30,0
    00853 075E      CPC	R21,R30
    00854 F409      BNE	0x0856
    00855 C053      RJMP	0x08A9
    00856 3043      CPI	R20,3
    00857 E0E0      LDI	R30,0
    00858 075E      CPC	R21,R30
    00859 F409      BNE	0x085B
    0085A C066      RJMP	0x08C1
    0085B 3044      CPI	R20,4
    0085C E0E0      LDI	R30,0
    0085D 075E      CPC	R21,R30
    0085E F409      BNE	0x0860
    0085F C079      RJMP	0x08D9
    00860 3045      CPI	R20,5
    00861 E0E0      LDI	R30,0
    00862 075E      CPC	R21,R30
    00863 F409      BNE	0x0865
    00864 C08B      RJMP	0x08F0
    00865 3046      CPI	R20,6
    00866 E0E0      LDI	R30,0
    00867 075E      CPC	R21,R30
    00868 F409      BNE	0x086A
    00869 C09E      RJMP	0x0908
    0086A 3047      CPI	R20,7
    0086B E0E0      LDI	R30,0
    0086C 075E      CPC	R21,R30
    0086D F409      BNE	0x086F
    0086E C0B1      RJMP	0x0920
    0086F 3048      CPI	R20,0x8
    00870 E0E0      LDI	R30,0
    00871 075E      CPC	R21,R30
    00872 F409      BNE	0x0874
    00873 C0C4      RJMP	0x0938
    00874 3049      CPI	R20,0x9
    00875 E0E0      LDI	R30,0
    00876 075E      CPC	R21,R30
    00877 F409      BNE	0x0879
    00878 C0D7      RJMP	0x0950
    00879 C0EE      RJMP	0x0968
(0533)       {
(0534)         case DISP_CODE_0: 
(0535) 		  g_disp_para = 0;
    0087A 2422      CLR	R2
    0087B 2433      CLR	R3
    0087C 9230 031B STS	g_disp_para+1,R3
    0087E 9220 031A STS	g_disp_para,R2
(0536) 	      if(timer_3s_cnt == 0) 
    00880 9020 01CB LDS	R2,timer_3s_cnt
    00882 9030 01CC LDS	R3,timer_3s_cnt+1
    00884 2022      TST	R2
    00885 F441      BNE	0x088E
    00886 2033      TST	R3
    00887 F431      BNE	0x088E
(0537)           {
(0538)             timer_3s_cnt++;
    00888 01C1      MOVW	R24,R2
    00889 9601      ADIW	R24,1
    0088A 9390 01CC STS	timer_3s_cnt+1,R25
    0088C 9380 01CB STS	timer_3s_cnt,R24
(0539)           }
(0540)           if(timer_3s_flag == TRUE)
    0088E 9180 01CD LDS	R24,timer_3s_flag
    00890 3081      CPI	R24,1
    00891 F469      BNE	0x089F
(0541)           {
(0542)             timer_3s_flag = FALSE;
    00892 2422      CLR	R2
    00893 9220 01CD STS	timer_3s_flag,R2
(0543)             timer_3s_cnt = 0;
    00895 2433      CLR	R3
    00896 9230 01CC STS	timer_3s_cnt+1,R3
    00898 9220 01CB STS	timer_3s_cnt,R2
(0544) 		    module_state = MODULE_STATE_WORK_NORM;
    0089A E082      LDI	R24,2
    0089B 9380 01EB STS	module_state,R24
(0545)             serv_state = SERV_STATE_MIN;
    0089D 9220 0183 STS	serv_prevState+17,R2
(0546)           }
(0547) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    0089F E082      LDI	R24,2
    008A0 8388      ST	Y,R24
    008A1 E021      LDI	R18,1
    008A2 9100 031A LDS	R16,g_disp_para
    008A4 9110 031B LDS	R17,g_disp_para+1
    008A6 940E 104F CALL	_Seg_164_Number
(0548)           break;
    008A8 C3DA      RJMP	0x0C83
(0549)         
(0550)         case DISP_CODE_1:
(0551) 		  g_disp_para = g_mt_full;
    008A9 9020 0326 LDS	R2,g_mt_full
    008AB 9030 0327 LDS	R3,g_mt_full+1
    008AD 9230 031B STS	g_disp_para+1,R3
    008AF 9220 031A STS	g_disp_para,R2
(0552) 		  timer_3s_cnt = 0;
    008B1 2422      CLR	R2
    008B2 2433      CLR	R3
    008B3 9230 01CC STS	timer_3s_cnt+1,R3
    008B5 9220 01CB STS	timer_3s_cnt,R2
(0553) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    008B7 E082      LDI	R24,2
    008B8 8388      ST	Y,R24
    008B9 E021      LDI	R18,1
    008BA 9100 031A LDS	R16,g_disp_para
    008BC 9110 031B LDS	R17,g_disp_para+1
    008BE 940E 104F CALL	_Seg_164_Number
(0554)           break;
    008C0 C3C2      RJMP	0x0C83
(0555)       
(0556)         case DISP_CODE_2:	  
(0557) 		  g_disp_para = g_mt_empty;
    008C1 9020 0324 LDS	R2,g_mt_empty
    008C3 9030 0325 LDS	R3,g_mt_empty+1
    008C5 9230 031B STS	g_disp_para+1,R3
    008C7 9220 031A STS	g_disp_para,R2
(0558) 		  timer_3s_cnt = 0;
    008C9 2422      CLR	R2
    008CA 2433      CLR	R3
    008CB 9230 01CC STS	timer_3s_cnt+1,R3
    008CD 9220 01CB STS	timer_3s_cnt,R2
(0559) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    008CF E082      LDI	R24,2
    008D0 8388      ST	Y,R24
    008D1 E021      LDI	R18,1
    008D2 9100 031A LDS	R16,g_disp_para
    008D4 9110 031B LDS	R17,g_disp_para+1
    008D6 940E 104F CALL	_Seg_164_Number
(0560)           break;
    008D8 C3AA      RJMP	0x0C83
(0561)       
(0562)         //case DISP_CODE_12:	
(0563) 		  //g_disp_para = g_hv_value;
(0564) 		  //timer_3s_cnt = 0;
(0565)           //break;
(0566) 		  
(0567)         case DISP_CODE_3:	
(0568) 		  g_disp_para = g_per_high;
    008D9 9020 0322 LDS	R2,g_per_high
    008DB 9030 0323 LDS	R3,g_per_high+1
    008DD 9230 031B STS	g_disp_para+1,R3
    008DF 9220 031A STS	g_disp_para,R2
(0569) 		  timer_3s_cnt = 0;
    008E1 2422      CLR	R2
    008E2 2433      CLR	R3
    008E3 9230 01CC STS	timer_3s_cnt+1,R3
    008E5 9220 01CB STS	timer_3s_cnt,R2
(0570) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_HIGH);
    008E7 8228      ST	Y,R2
    008E8 E021      LDI	R18,1
    008E9 9100 031A LDS	R16,g_disp_para
    008EB 9110 031B LDS	R17,g_disp_para+1
    008ED 940E 104F CALL	_Seg_164_Number
(0571) 		  break;
    008EF C393      RJMP	0x0C83
(0572) 		  
(0573) 	    case DISP_CODE_4:	
(0574) 		  g_disp_para = g_per_low;
    008F0 9020 0320 LDS	R2,g_per_low
    008F2 9030 0321 LDS	R3,g_per_low+1
    008F4 9230 031B STS	g_disp_para+1,R3
    008F6 9220 031A STS	g_disp_para,R2
(0575) 		  timer_3s_cnt = 0;
    008F8 2422      CLR	R2
    008F9 2433      CLR	R3
    008FA 9230 01CC STS	timer_3s_cnt+1,R3
    008FC 9220 01CB STS	timer_3s_cnt,R2
(0576) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_LOW);
    008FE E081      LDI	R24,1
    008FF 8388      ST	Y,R24
    00900 E021      LDI	R18,1
    00901 9100 031A LDS	R16,g_disp_para
    00903 9110 031B LDS	R17,g_disp_para+1
    00905 940E 104F CALL	_Seg_164_Number
(0577) 		  break;
    00907 C37B      RJMP	0x0C83
(0578) 		  
(0579) 		  
(0580)         case DISP_CODE_5:	 
(0581) 		  g_disp_para = g_resp_time;
    00908 9020 031E LDS	R2,g_resp_time
    0090A 9030 031F LDS	R3,g_resp_time+1
    0090C 9230 031B STS	g_disp_para+1,R3
    0090E 9220 031A STS	g_disp_para,R2
(0582) 		  timer_3s_cnt = 0;
    00910 2422      CLR	R2
    00911 2433      CLR	R3
    00912 9230 01CC STS	timer_3s_cnt+1,R3
    00914 9220 01CB STS	timer_3s_cnt,R2
(0583) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    00916 E082      LDI	R24,2
    00917 8388      ST	Y,R24
    00918 E021      LDI	R18,1
    00919 9100 031A LDS	R16,g_disp_para
    0091B 9110 031B LDS	R17,g_disp_para+1
    0091D 940E 104F CALL	_Seg_164_Number
(0584)           break;
    0091F C363      RJMP	0x0C83
(0585) 		  
(0586)         case DISP_CODE_6:	 
(0587) 		  g_disp_para = g_resp_time;
    00920 9020 031E LDS	R2,g_resp_time
    00922 9030 031F LDS	R3,g_resp_time+1
    00924 9230 031B STS	g_disp_para+1,R3
    00926 9220 031A STS	g_disp_para,R2
(0588) 		  timer_3s_cnt = 0;
    00928 2422      CLR	R2
    00929 2433      CLR	R3
    0092A 9230 01CC STS	timer_3s_cnt+1,R3
    0092C 9220 01CB STS	timer_3s_cnt,R2
(0589) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    0092E E082      LDI	R24,2
    0092F 8388      ST	Y,R24
    00930 E021      LDI	R18,1
    00931 9100 031A LDS	R16,g_disp_para
    00933 9110 031B LDS	R17,g_disp_para+1
    00935 940E 104F CALL	_Seg_164_Number
(0590)           break;
    00937 C34B      RJMP	0x0C83
(0591) 		  
(0592) 		case DISP_CODE_7:	 
(0593) 		  g_disp_para = g_addr_code;
    00938 9020 0328 LDS	R2,g_addr_code
    0093A 9030 0329 LDS	R3,g_addr_code+1
    0093C 9230 031B STS	g_disp_para+1,R3
    0093E 9220 031A STS	g_disp_para,R2
(0594) 		  timer_3s_cnt = 0;
    00940 2422      CLR	R2
    00941 2433      CLR	R3
    00942 9230 01CC STS	timer_3s_cnt+1,R3
    00944 9220 01CB STS	timer_3s_cnt,R2
(0595) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    00946 E082      LDI	R24,2
    00947 8388      ST	Y,R24
    00948 E021      LDI	R18,1
    00949 9100 031A LDS	R16,g_disp_para
    0094B 9110 031B LDS	R17,g_disp_para+1
    0094D 940E 104F CALL	_Seg_164_Number
(0596)           break;
    0094F C333      RJMP	0x0C83
(0597) 		  
(0598)         case DISP_CODE_8:	 
(0599) 		  g_disp_para = g_addr_code;
    00950 9020 0328 LDS	R2,g_addr_code
    00952 9030 0329 LDS	R3,g_addr_code+1
    00954 9230 031B STS	g_disp_para+1,R3
    00956 9220 031A STS	g_disp_para,R2
(0600) 		  timer_3s_cnt = 0;
    00958 2422      CLR	R2
    00959 2433      CLR	R3
    0095A 9230 01CC STS	timer_3s_cnt+1,R3
    0095C 9220 01CB STS	timer_3s_cnt,R2
(0601) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    0095E E082      LDI	R24,2
    0095F 8388      ST	Y,R24
    00960 E021      LDI	R18,1
    00961 9100 031A LDS	R16,g_disp_para
    00963 9110 031B LDS	R17,g_disp_para+1
    00965 940E 104F CALL	_Seg_164_Number
(0602)           break;
    00967 C31B      RJMP	0x0C83
(0603) 		  
(0604)         default:
(0605) 		  timer_3s_cnt = 0;
    00968 2422      CLR	R2
    00969 2433      CLR	R3
    0096A 9230 01CC STS	timer_3s_cnt+1,R3
    0096C 9220 01CB STS	timer_3s_cnt,R2
(0606)           break;
(0607)       }
(0608) 
(0609)       break;
    0096E C314      RJMP	0x0C83
(0610)     
(0611)     case SERV_STATE_PARA_CHANGE:	 
(0612) 	  switch(g_disp_code)
    0096F 9140 0319 LDS	R20,g_disp_code
    00971 2755      CLR	R21
    00972 3041      CPI	R20,1
    00973 E0E0      LDI	R30,0
    00974 075E      CPC	R21,R30
    00975 F149      BEQ	0x099F
    00976 3042      CPI	R20,2
    00977 E0E0      LDI	R30,0
    00978 075E      CPC	R21,R30
    00979 F409      BNE	0x097B
    0097A C031      RJMP	0x09AC
    0097B 3043      CPI	R20,3
    0097C E0E0      LDI	R30,0
    0097D 075E      CPC	R21,R30
    0097E F409      BNE	0x0980
    0097F C068      RJMP	0x09E8
    00980 3044      CPI	R20,4
    00981 E0E0      LDI	R30,0
    00982 075E      CPC	R21,R30
    00983 F409      BNE	0x0985
    00984 C0A3      RJMP	0x0A28
    00985 3045      CPI	R20,5
    00986 E0E0      LDI	R30,0
    00987 075E      CPC	R21,R30
    00988 F409      BNE	0x098A
    00989 C0DC      RJMP	0x0A66
    0098A 3046      CPI	R20,6
    0098B E0E0      LDI	R30,0
    0098C 075E      CPC	R21,R30
    0098D F409      BNE	0x098F
    0098E C112      RJMP	0x0AA1
    0098F 3047      CPI	R20,7
    00990 E0E0      LDI	R30,0
    00991 075E      CPC	R21,R30
    00992 F409      BNE	0x0994
    00993 C134      RJMP	0x0AC8
    00994 3048      CPI	R20,0x8
    00995 E0E0      LDI	R30,0
    00996 075E      CPC	R21,R30
    00997 F409      BNE	0x0999
    00998 C151      RJMP	0x0AEA
    00999 3049      CPI	R20,0x9
    0099A E0E0      LDI	R30,0
    0099B 075E      CPC	R21,R30
    0099C F409      BNE	0x099E
    0099D C174      RJMP	0x0B12
    0099E C19A      RJMP	0x0B39
(0613)       {
(0614)         case DISP_CODE_0: 
(0615) 	      g_disp_para = 0;
    0099F 2422      CLR	R2
    009A0 2433      CLR	R3
    009A1 9230 031B STS	g_disp_para+1,R3
    009A3 9220 031A STS	g_disp_para,R2
(0616) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    009A5 E082      LDI	R24,2
    009A6 8388      ST	Y,R24
    009A7 E021      LDI	R18,1
    009A8 0181      MOVW	R16,R2
    009A9 940E 104F CALL	_Seg_164_Number
(0617)           break;
    009AB C18D      RJMP	0x0B39
(0618)         
(0619)         case DISP_CODE_1:
(0620) 		  g_disp_para += 10;
    009AC 9180 031A LDS	R24,g_disp_para
    009AE 9190 031B LDS	R25,g_disp_para+1
    009B0 960A      ADIW	R24,0xA
    009B1 9390 031B STS	g_disp_para+1,R25
    009B3 9380 031A STS	g_disp_para,R24
(0621)           if((g_disp_para >= DISP_PARA_MAX) || (g_disp_para <= DISP_PARA_MIN))
    009B5 01AC      MOVW	R20,R24
    009B6 3E88      CPI	R24,0xE8
    009B7 E0E3      LDI	R30,3
    009B8 079E      CPC	R25,R30
    009B9 F428      BCC	0x09BF
    009BA E684      LDI	R24,0x64
    009BB E090      LDI	R25,0
    009BC 1784      CP	R24,R20
    009BD 0795      CPC	R25,R21
    009BE F030      BCS	0x09C5
(0622)           {
(0623)             g_disp_para = DISP_PARA_MIN;
    009BF E684      LDI	R24,0x64
    009C0 E090      LDI	R25,0
    009C1 9390 031B STS	g_disp_para+1,R25
    009C3 9380 031A STS	g_disp_para,R24
(0624)           }
(0625) 		  if(g_disp_para <= g_mt_empty)
    009C5 9020 0324 LDS	R2,g_mt_empty
    009C7 9030 0325 LDS	R3,g_mt_empty+1
    009C9 9040 031A LDS	R4,g_disp_para
    009CB 9050 031B LDS	R5,g_disp_para+1
    009CD 1424      CP	R2,R4
    009CE 0435      CPC	R3,R5
    009CF F028      BCS	0x09D5
(0626) 		  {
(0627) 		    LedLight(LED_D1, ON);
    009D0 E021      LDI	R18,1
    009D1 E001      LDI	R16,1
    009D2 940E 0D37 CALL	_LedLight
(0628) 		  }
    009D4 C004      RJMP	0x09D9
(0629) 		  else
(0630) 		  {
(0631) 		    LedLight(LED_D1, OFF);
    009D5 2722      CLR	R18
    009D6 E001      LDI	R16,1
    009D7 940E 0D37 CALL	_LedLight
(0632) 		  }
(0633)           g_mt_full = g_disp_para;
    009D9 9020 031A LDS	R2,g_disp_para
    009DB 9030 031B LDS	R3,g_disp_para+1
    009DD 9230 0327 STS	g_mt_full+1,R3
    009DF 9220 0326 STS	g_mt_full,R2
(0634) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    009E1 E082      LDI	R24,2
    009E2 8388      ST	Y,R24
    009E3 E021      LDI	R18,1
    009E4 0181      MOVW	R16,R2
    009E5 940E 104F CALL	_Seg_164_Number
(0635)           break;
    009E7 C151      RJMP	0x0B39
(0636)       
(0637)         case DISP_CODE_2:	  
(0638) 		  g_disp_para += 10;
    009E8 9180 031A LDS	R24,g_disp_para
    009EA 9190 031B LDS	R25,g_disp_para+1
    009EC 960A      ADIW	R24,0xA
    009ED 9390 031B STS	g_disp_para+1,R25
    009EF 9380 031A STS	g_disp_para,R24
(0639)           if((g_disp_para >= DISP_PARA_MAX) || (g_disp_para <= DISP_PARA_MIN))
    009F1 01AC      MOVW	R20,R24
    009F2 3E88      CPI	R24,0xE8
    009F3 E0E3      LDI	R30,3
    009F4 079E      CPC	R25,R30
    009F5 F428      BCC	0x09FB
    009F6 E684      LDI	R24,0x64
    009F7 E090      LDI	R25,0
    009F8 1784      CP	R24,R20
    009F9 0795      CPC	R25,R21
    009FA F050      BCS	0x0A05
(0640)           {
(0641)             g_disp_para = DISP_PARA_MIN;
    009FB E684      LDI	R24,0x64
    009FC E090      LDI	R25,0
    009FD 9390 031B STS	g_disp_para+1,R25
    009FF 9380 031A STS	g_disp_para,R24
(0642) 			LedLight(LED_D1, ON);
    00A01 E021      LDI	R18,1
    00A02 E001      LDI	R16,1
    00A03 940E 0D37 CALL	_LedLight
(0643)           }
(0644) 		  
(0645) 		  if(g_disp_para >= g_mt_full)
    00A05 9020 0326 LDS	R2,g_mt_full
    00A07 9030 0327 LDS	R3,g_mt_full+1
    00A09 9040 031A LDS	R4,g_disp_para
    00A0B 9050 031B LDS	R5,g_disp_para+1
    00A0D 1442      CP	R4,R2
    00A0E 0453      CPC	R5,R3
    00A0F F028      BCS	0x0A15
(0646) 		  {
(0647) 		    LedLight(LED_D1, ON);
    00A10 E021      LDI	R18,1
    00A11 E001      LDI	R16,1
    00A12 940E 0D37 CALL	_LedLight
(0648) 		  }
    00A14 C004      RJMP	0x0A19
(0649) 		  else
(0650) 		  {
(0651) 		    LedLight(LED_D1, OFF);
    00A15 2722      CLR	R18
    00A16 E001      LDI	R16,1
    00A17 940E 0D37 CALL	_LedLight
(0652) 		  }
(0653)           g_mt_empty = g_disp_para;
    00A19 9020 031A LDS	R2,g_disp_para
    00A1B 9030 031B LDS	R3,g_disp_para+1
    00A1D 9230 0325 STS	g_mt_empty+1,R3
    00A1F 9220 0324 STS	g_mt_empty,R2
(0654) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    00A21 E082      LDI	R24,2
    00A22 8388      ST	Y,R24
    00A23 E021      LDI	R18,1
    00A24 0181      MOVW	R16,R2
    00A25 940E 104F CALL	_Seg_164_Number
(0655)           break;
    00A27 C111      RJMP	0x0B39
(0656)       
(0657)         //case DISP_CODE_12:	
(0658)           //g_hv_value = g_disp_para;
(0659)           //break;
(0660) 		  
(0661)         case DISP_CODE_3:
(0662)           g_disp_para += 5;
    00A28 9180 031A LDS	R24,g_disp_para
    00A2A 9190 031B LDS	R25,g_disp_para+1
    00A2C 9605      ADIW	R24,5
    00A2D 9390 031B STS	g_disp_para+1,R25
    00A2F 9380 031A STS	g_disp_para,R24
(0663)           if(g_disp_para > 100)
    00A31 E684      LDI	R24,0x64
    00A32 E090      LDI	R25,0
    00A33 9020 031A LDS	R2,g_disp_para
    00A35 9030 031B LDS	R3,g_disp_para+1
    00A37 1582      CP	R24,R2
    00A38 0593      CPC	R25,R3
    00A39 F430      BCC	0x0A40
(0664)           {
(0665)             g_disp_para = 0;
    00A3A 2422      CLR	R2
    00A3B 2433      CLR	R3
    00A3C 9230 031B STS	g_disp_para+1,R3
    00A3E 9220 031A STS	g_disp_para,R2
(0666)           }
(0667) 		  if(g_disp_para <= g_per_low)
    00A40 9020 0320 LDS	R2,g_per_low
    00A42 9030 0321 LDS	R3,g_per_low+1
    00A44 9040 031A LDS	R4,g_disp_para
    00A46 9050 031B LDS	R5,g_disp_para+1
    00A48 1424      CP	R2,R4
    00A49 0435      CPC	R3,R5
    00A4A F028      BCS	0x0A50
(0668) 		  {
(0669) 		    LedLight(LED_D1, ON);
    00A4B E021      LDI	R18,1
    00A4C E001      LDI	R16,1
    00A4D 940E 0D37 CALL	_LedLight
(0670) 		  }
    00A4F C004      RJMP	0x0A54
(0671) 		  else
(0672) 		  {
(0673) 		    LedLight(LED_D1, OFF);
    00A50 2722      CLR	R18
    00A51 E001      LDI	R16,1
    00A52 940E 0D37 CALL	_LedLight
(0674) 		  }
(0675)           g_per_high = g_disp_para;	
    00A54 9020 031A LDS	R2,g_disp_para
    00A56 9030 031B LDS	R3,g_disp_para+1
    00A58 9230 0323 STS	g_per_high+1,R3
    00A5A 9220 0322 STS	g_per_high,R2
(0676) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_HIGH);
    00A5C 2422      CLR	R2
    00A5D 8228      ST	Y,R2
    00A5E E021      LDI	R18,1
    00A5F 9100 031A LDS	R16,g_disp_para
    00A61 9110 031B LDS	R17,g_disp_para+1
    00A63 940E 104F CALL	_Seg_164_Number
(0677) 		  break;
    00A65 C0D3      RJMP	0x0B39
(0678) 		  
(0679) 	    case DISP_CODE_4:	
(0680) 		  g_disp_para += 5;
    00A66 9180 031A LDS	R24,g_disp_para
    00A68 9190 031B LDS	R25,g_disp_para+1
    00A6A 9605      ADIW	R24,5
    00A6B 9390 031B STS	g_disp_para+1,R25
    00A6D 9380 031A STS	g_disp_para,R24
(0681)           if(g_disp_para > 100)
    00A6F E684      LDI	R24,0x64
    00A70 E090      LDI	R25,0
    00A71 9020 031A LDS	R2,g_disp_para
    00A73 9030 031B LDS	R3,g_disp_para+1
    00A75 1582      CP	R24,R2
    00A76 0593      CPC	R25,R3
    00A77 F430      BCC	0x0A7E
(0682)           {
(0683)             g_disp_para = 0;
    00A78 2422      CLR	R2
    00A79 2433      CLR	R3
    00A7A 9230 031B STS	g_disp_para+1,R3
    00A7C 9220 031A STS	g_disp_para,R2
(0684)           }
(0685) 		  if(g_disp_para >= g_per_high)
    00A7E 9020 0322 LDS	R2,g_per_high
    00A80 9030 0323 LDS	R3,g_per_high+1
    00A82 9040 031A LDS	R4,g_disp_para
    00A84 9050 031B LDS	R5,g_disp_para+1
    00A86 1442      CP	R4,R2
    00A87 0453      CPC	R5,R3
    00A88 F028      BCS	0x0A8E
(0686) 		  {
(0687) 		    LedLight(LED_D1, ON);
    00A89 E021      LDI	R18,1
    00A8A E001      LDI	R16,1
    00A8B 940E 0D37 CALL	_LedLight
(0688) 		  }
    00A8D C004      RJMP	0x0A92
(0689) 		  else
(0690) 		  {
(0691) 		    LedLight(LED_D1, OFF);
    00A8E 2722      CLR	R18
    00A8F E001      LDI	R16,1
    00A90 940E 0D37 CALL	_LedLight
(0692) 		  }
(0693)           g_per_low = g_disp_para;	
    00A92 9020 031A LDS	R2,g_disp_para
    00A94 9030 031B LDS	R3,g_disp_para+1
    00A96 9230 0321 STS	g_per_low+1,R3
    00A98 9220 0320 STS	g_per_low,R2
(0694) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_LOW);
    00A9A E081      LDI	R24,1
    00A9B 8388      ST	Y,R24
    00A9C E021      LDI	R18,1
    00A9D 0181      MOVW	R16,R2
    00A9E 940E 104F CALL	_Seg_164_Number
(0695) 		  break;
    00AA0 C098      RJMP	0x0B39
(0696) 		
(0697)         case DISP_CODE_5:	 
(0698) 		  g_disp_para += 1;
    00AA1 9180 031A LDS	R24,g_disp_para
    00AA3 9190 031B LDS	R25,g_disp_para+1
    00AA5 9601      ADIW	R24,1
    00AA6 9390 031B STS	g_disp_para+1,R25
    00AA8 9380 031A STS	g_disp_para,R24
(0699)           if(g_disp_para > 450) 
    00AAA EC82      LDI	R24,0xC2
    00AAB E091      LDI	R25,1
    00AAC 9020 031A LDS	R2,g_disp_para
    00AAE 9030 031B LDS	R3,g_disp_para+1
    00AB0 1582      CP	R24,R2
    00AB1 0593      CPC	R25,R3
    00AB2 F430      BCC	0x0AB9
(0700)           {
(0701)             g_disp_para = 3;
    00AB3 E083      LDI	R24,3
    00AB4 E090      LDI	R25,0
    00AB5 9390 031B STS	g_disp_para+1,R25
    00AB7 9380 031A STS	g_disp_para,R24
(0702)           }
(0703)           g_resp_time = g_disp_para;
    00AB9 9020 031A LDS	R2,g_disp_para
    00ABB 9030 031B LDS	R3,g_disp_para+1
    00ABD 9230 031F STS	g_resp_time+1,R3
    00ABF 9220 031E STS	g_resp_time,R2
(0704) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    00AC1 E082      LDI	R24,2
    00AC2 8388      ST	Y,R24
    00AC3 E021      LDI	R18,1
    00AC4 0181      MOVW	R16,R2
    00AC5 940E 104F CALL	_Seg_164_Number
(0705)           break;
    00AC7 C071      RJMP	0x0B39
(0706) 		  
(0707)         case DISP_CODE_6:	 
(0708) 		  g_disp_para -= 1;
    00AC8 9180 031A LDS	R24,g_disp_para
    00ACA 9190 031B LDS	R25,g_disp_para+1
    00ACC 9701      SBIW	R24,1
    00ACD 9390 031B STS	g_disp_para+1,R25
    00ACF 9380 031A STS	g_disp_para,R24
(0709)           if(g_disp_para < 3)
    00AD1 3083      CPI	R24,3
    00AD2 E0E0      LDI	R30,0
    00AD3 079E      CPC	R25,R30
    00AD4 F430      BCC	0x0ADB
(0710)           {
(0711)             g_disp_para = 450;
    00AD5 EC82      LDI	R24,0xC2
    00AD6 E091      LDI	R25,1
    00AD7 9390 031B STS	g_disp_para+1,R25
    00AD9 9380 031A STS	g_disp_para,R24
(0712)           }
(0713)           g_resp_time = g_disp_para;
    00ADB 9020 031A LDS	R2,g_disp_para
    00ADD 9030 031B LDS	R3,g_disp_para+1
    00ADF 9230 031F STS	g_resp_time+1,R3
    00AE1 9220 031E STS	g_resp_time,R2
(0714) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    00AE3 E082      LDI	R24,2
    00AE4 8388      ST	Y,R24
    00AE5 E021      LDI	R18,1
    00AE6 0181      MOVW	R16,R2
    00AE7 940E 104F CALL	_Seg_164_Number
(0715)           break;   
    00AE9 C04F      RJMP	0x0B39
(0716) 		  
(0717) 	    case DISP_CODE_7:	 
(0718) 		  g_disp_para += 1;
    00AEA 9180 031A LDS	R24,g_disp_para
    00AEC 9190 031B LDS	R25,g_disp_para+1
    00AEE 9601      ADIW	R24,1
    00AEF 9390 031B STS	g_disp_para+1,R25
    00AF1 9380 031A STS	g_disp_para,R24
(0719)           if((g_disp_para > 9999) || (g_disp_para < 1000))
    00AF3 01AC      MOVW	R20,R24
    00AF4 E08F      LDI	R24,0xF
    00AF5 E297      LDI	R25,0x27
    00AF6 1784      CP	R24,R20
    00AF7 0795      CPC	R25,R21
    00AF8 F020      BCS	0x0AFD
    00AF9 3E48      CPI	R20,0xE8
    00AFA E0E3      LDI	R30,3
    00AFB 075E      CPC	R21,R30
    00AFC F430      BCC	0x0B03
(0720)           {
(0721)             g_disp_para = 1000;
    00AFD EE88      LDI	R24,0xE8
    00AFE E093      LDI	R25,3
    00AFF 9390 031B STS	g_disp_para+1,R25
    00B01 9380 031A STS	g_disp_para,R24
(0722)           }
(0723)           g_addr_code = g_disp_para;
    00B03 9020 031A LDS	R2,g_disp_para
    00B05 9030 031B LDS	R3,g_disp_para+1
    00B07 9230 0329 STS	g_addr_code+1,R3
    00B09 9220 0328 STS	g_addr_code,R2
(0724) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    00B0B E082      LDI	R24,2
    00B0C 8388      ST	Y,R24
    00B0D E021      LDI	R18,1
    00B0E 0181      MOVW	R16,R2
    00B0F 940E 104F CALL	_Seg_164_Number
(0725)           break;
    00B11 C027      RJMP	0x0B39
(0726) 		  
(0727)         case DISP_CODE_8:	 
(0728) 		  g_disp_para -= 1;
    00B12 9180 031A LDS	R24,g_disp_para
    00B14 9190 031B LDS	R25,g_disp_para+1
    00B16 9701      SBIW	R24,1
    00B17 9390 031B STS	g_disp_para+1,R25
    00B19 9380 031A STS	g_disp_para,R24
(0729)           if((g_disp_para > 9999) || (g_disp_para < 1000))
    00B1B 01AC      MOVW	R20,R24
    00B1C E08F      LDI	R24,0xF
    00B1D E297      LDI	R25,0x27
    00B1E 1784      CP	R24,R20
    00B1F 0795      CPC	R25,R21
    00B20 F020      BCS	0x0B25
    00B21 3E48      CPI	R20,0xE8
    00B22 E0E3      LDI	R30,3
    00B23 075E      CPC	R21,R30
    00B24 F430      BCC	0x0B2B
(0730)           {
(0731)             g_disp_para = 9999;
    00B25 E08F      LDI	R24,0xF
    00B26 E297      LDI	R25,0x27
    00B27 9390 031B STS	g_disp_para+1,R25
    00B29 9380 031A STS	g_disp_para,R24
(0732)           }
(0733)           g_addr_code = g_disp_para;
    00B2B 9020 031A LDS	R2,g_disp_para
    00B2D 9030 031B LDS	R3,g_disp_para+1
    00B2F 9230 0329 STS	g_addr_code+1,R3
    00B31 9220 0328 STS	g_addr_code,R2
(0734) 		  Seg_164_Number(g_disp_para, SEG_COLOR_GREEN, MARK_NULL);
    00B33 E082      LDI	R24,2
    00B34 8388      ST	Y,R24
    00B35 E021      LDI	R18,1
    00B36 0181      MOVW	R16,R2
    00B37 940E 104F CALL	_Seg_164_Number
(0735)           break;  
(0736) 		  
(0737)         default:
(0738)           break;
(0739)       }
(0740) 	  serv_prevState = serv_state;
    00B39 9020 0183 LDS	R2,serv_prevState+17
    00B3B 9220 0184 STS	serv_prevState+18,R2
(0741) 	  serv_state = SERV_STATE_MIN;
    00B3D 2422      CLR	R2
    00B3E 9220 0183 STS	serv_prevState+17,R2
(0742)       break;
    00B40 C142      RJMP	0x0C83
(0743) 
(0744)     case SERV_STATE_PARA_SAVE:	
(0745) 	  if(g_mt_full <= g_mt_empty)
    00B41 9020 0324 LDS	R2,g_mt_empty
    00B43 9030 0325 LDS	R3,g_mt_empty+1
    00B45 9040 0326 LDS	R4,g_mt_full
    00B47 9050 0327 LDS	R5,g_mt_full+1
    00B49 1424      CP	R2,R4
    00B4A 0435      CPC	R3,R5
    00B4B F0D8      BCS	0x0B67
(0746) 	  {
(0747) 	    g_mt_full = g_mt_empty;
    00B4C 9230 0327 STS	g_mt_full+1,R3
    00B4E 9220 0326 STS	g_mt_full,R2
(0748) 		if(g_mt_empty > 400)
    00B50 E980      LDI	R24,0x90
    00B51 E091      LDI	R25,1
    00B52 1582      CP	R24,R2
    00B53 0593      CPC	R25,R3
    00B54 F440      BCC	0x0B5D
(0749) 		{
(0750) 		  g_mt_empty -= 100;
    00B55 01C1      MOVW	R24,R2
    00B56 5684      SUBI	R24,0x64
    00B57 4090      SBCI	R25,0
    00B58 9390 0325 STS	g_mt_empty+1,R25
    00B5A 9380 0324 STS	g_mt_empty,R24
(0751) 		}
    00B5C C00A      RJMP	0x0B67
(0752) 		else
(0753) 		{
(0754) 		  g_mt_full += 100;
    00B5D 9180 0326 LDS	R24,g_mt_full
    00B5F 9190 0327 LDS	R25,g_mt_full+1
    00B61 598C      SUBI	R24,0x9C
    00B62 4F9F      SBCI	R25,0xFF
    00B63 9390 0327 STS	g_mt_full+1,R25
    00B65 9380 0326 STS	g_mt_full,R24
(0755) 		}
(0756) 	  }  
(0757) 	  
(0758) 	  if(g_per_high <= g_per_low)
    00B67 9020 0320 LDS	R2,g_per_low
    00B69 9030 0321 LDS	R3,g_per_low+1
    00B6B 9040 0322 LDS	R4,g_per_high
    00B6D 9050 0323 LDS	R5,g_per_high+1
    00B6F 1424      CP	R2,R4
    00B70 0435      CPC	R3,R5
    00B71 F0C8      BCS	0x0B8B
(0759) 	  {
(0760) 	    g_per_high = g_per_low;
    00B72 9230 0323 STS	g_per_high+1,R3
    00B74 9220 0322 STS	g_per_high,R2
(0761) 		if(g_per_low > 50)
    00B76 E382      LDI	R24,0x32
    00B77 E090      LDI	R25,0
    00B78 1582      CP	R24,R2
    00B79 0593      CPC	R25,R3
    00B7A F438      BCC	0x0B82
(0762) 		{
(0763) 		  g_per_low -= 10;
    00B7B 01C1      MOVW	R24,R2
    00B7C 970A      SBIW	R24,0xA
    00B7D 9390 0321 STS	g_per_low+1,R25
    00B7F 9380 0320 STS	g_per_low,R24
(0764) 		}
    00B81 C009      RJMP	0x0B8B
(0765) 		else
(0766) 		{
(0767) 		  g_per_high += 10;
    00B82 9180 0322 LDS	R24,g_per_high
    00B84 9190 0323 LDS	R25,g_per_high+1
    00B86 960A      ADIW	R24,0xA
    00B87 9390 0323 STS	g_per_high+1,R25
    00B89 9380 0322 STS	g_per_high,R24
(0768) 		}
(0769) 	  }  
(0770) 	  
(0771) 	  if(timer_3s_cnt == 0) 
    00B8B 9020 01CB LDS	R2,timer_3s_cnt
    00B8D 9030 01CC LDS	R3,timer_3s_cnt+1
    00B8F 2022      TST	R2
    00B90 F441      BNE	0x0B99
    00B91 2033      TST	R3
    00B92 F431      BNE	0x0B99
(0772)       {
(0773)         timer_3s_cnt++;
    00B93 01C1      MOVW	R24,R2
    00B94 9601      ADIW	R24,1
    00B95 9390 01CC STS	timer_3s_cnt+1,R25
    00B97 9380 01CB STS	timer_3s_cnt,R24
(0774)       }
(0775)       if(timer_3s_flag == TRUE)
    00B99 9180 01CD LDS	R24,timer_3s_flag
    00B9B 3081      CPI	R24,1
    00B9C F009      BEQ	0x0B9E
    00B9D C0E5      RJMP	0x0C83
(0776)       {
(0777)         timer_3s_flag = FALSE;
    00B9E 2422      CLR	R2
    00B9F 9220 01CD STS	timer_3s_flag,R2
(0778)         timer_3s_cnt = 0;
    00BA1 2433      CLR	R3
    00BA2 9230 01CC STS	timer_3s_cnt+1,R3
    00BA4 9220 01CB STS	timer_3s_cnt,R2
(0779) 		me_mt_full.highByte = g_mt_full/100;
    00BA6 E624      LDI	R18,0x64
    00BA7 E030      LDI	R19,0
    00BA8 9100 0326 LDS	R16,g_mt_full
    00BAA 9110 0327 LDS	R17,g_mt_full+1
    00BAC 940E 1152 CALL	div16u
    00BAE 9300 01D7 STS	me_mt_full,R16
(0780)         me_mt_full.lowByte = g_mt_full%100;
    00BB0 E624      LDI	R18,0x64
    00BB1 E030      LDI	R19,0
    00BB2 9100 0326 LDS	R16,g_mt_full
    00BB4 9110 0327 LDS	R17,g_mt_full+1
    00BB6 940E 1150 CALL	mod16u
    00BB8 9300 01D8 STS	me_mt_full+1,R16
(0781)         EEPROM_Write_Bytes(MT_FULL_ADDR, &me_mt_full.highByte, 2);
    00BBA E082      LDI	R24,2
    00BBB E090      LDI	R25,0
    00BBC 8399      STD	Y+1,R25
    00BBD 8388      ST	Y,R24
    00BBE ED27      LDI	R18,0xD7
    00BBF E031      LDI	R19,1
    00BC0 E200      LDI	R16,0x20
    00BC1 E010      LDI	R17,0
    00BC2 940E 0E0D CALL	_EEPROM_Write_Bytes
(0782)         me_mt_empty.highByte = g_mt_empty/100;
    00BC4 E624      LDI	R18,0x64
    00BC5 E030      LDI	R19,0
    00BC6 9100 0324 LDS	R16,g_mt_empty
    00BC8 9110 0325 LDS	R17,g_mt_empty+1
    00BCA 940E 1152 CALL	div16u
    00BCC 9300 01D9 STS	me_mt_empty,R16
(0783)         me_mt_empty.lowByte = g_mt_empty%100;
    00BCE E624      LDI	R18,0x64
    00BCF E030      LDI	R19,0
    00BD0 9100 0324 LDS	R16,g_mt_empty
    00BD2 9110 0325 LDS	R17,g_mt_empty+1
    00BD4 940E 1150 CALL	mod16u
    00BD6 9300 01DA STS	me_mt_empty+1,R16
(0784)         EEPROM_Write_Bytes(MT_EMPTY_ADDR, &me_mt_empty.highByte, 2);
    00BD8 E082      LDI	R24,2
    00BD9 E090      LDI	R25,0
    00BDA 8399      STD	Y+1,R25
    00BDB 8388      ST	Y,R24
    00BDC ED29      LDI	R18,0xD9
    00BDD E031      LDI	R19,1
    00BDE E208      LDI	R16,0x28
    00BDF E010      LDI	R17,0
    00BE0 940E 0E0D CALL	_EEPROM_Write_Bytes
(0785) 		
(0786) 		me_per_high.highByte = g_per_high/100;
    00BE2 E624      LDI	R18,0x64
    00BE3 E030      LDI	R19,0
    00BE4 9100 0322 LDS	R16,g_per_high
    00BE6 9110 0323 LDS	R17,g_per_high+1
    00BE8 940E 1152 CALL	div16u
    00BEA 9300 01DB STS	me_per_high,R16
(0787)         me_per_high.lowByte = g_per_high%100;
    00BEC E624      LDI	R18,0x64
    00BED E030      LDI	R19,0
    00BEE 9100 0322 LDS	R16,g_per_high
    00BF0 9110 0323 LDS	R17,g_per_high+1
    00BF2 940E 1150 CALL	mod16u
    00BF4 9300 01DC STS	me_per_high+1,R16
(0788)         EEPROM_Write_Bytes(PER_HIGH_ADDR, &me_per_high.highByte, 2);
    00BF6 E082      LDI	R24,2
    00BF7 E090      LDI	R25,0
    00BF8 8399      STD	Y+1,R25
    00BF9 8388      ST	Y,R24
    00BFA ED2B      LDI	R18,0xDB
    00BFB E031      LDI	R19,1
    00BFC E300      LDI	R16,0x30
    00BFD E010      LDI	R17,0
    00BFE 940E 0E0D CALL	_EEPROM_Write_Bytes
(0789)         me_per_low.highByte = g_per_low/100;
    00C00 E624      LDI	R18,0x64
    00C01 E030      LDI	R19,0
    00C02 9100 0320 LDS	R16,g_per_low
    00C04 9110 0321 LDS	R17,g_per_low+1
    00C06 940E 1152 CALL	div16u
    00C08 9300 01DD STS	me_per_low,R16
(0790)         me_per_low.lowByte = g_per_low%100;
    00C0A E624      LDI	R18,0x64
    00C0B E030      LDI	R19,0
    00C0C 9100 0320 LDS	R16,g_per_low
    00C0E 9110 0321 LDS	R17,g_per_low+1
    00C10 940E 1150 CALL	mod16u
    00C12 9300 01DE STS	me_per_low+1,R16
(0791)         EEPROM_Write_Bytes(PER_LOW_ADDR, &me_per_low.highByte, 2);	
    00C14 E082      LDI	R24,2
    00C15 E090      LDI	R25,0
    00C16 8399      STD	Y+1,R25
    00C17 8388      ST	Y,R24
    00C18 ED2D      LDI	R18,0xDD
    00C19 E031      LDI	R19,1
    00C1A E308      LDI	R16,0x38
    00C1B E010      LDI	R17,0
    00C1C 940E 0E0D CALL	_EEPROM_Write_Bytes
(0792) 		
(0793) 		me_resp_time.highByte = g_resp_time/100;
    00C1E E624      LDI	R18,0x64
    00C1F E030      LDI	R19,0
    00C20 9100 031E LDS	R16,g_resp_time
    00C22 9110 031F LDS	R17,g_resp_time+1
    00C24 940E 1152 CALL	div16u
    00C26 9300 01DF STS	me_resp_time,R16
(0794)         me_resp_time.lowByte = g_resp_time%100;
    00C28 E624      LDI	R18,0x64
    00C29 E030      LDI	R19,0
    00C2A 9100 031E LDS	R16,g_resp_time
    00C2C 9110 031F LDS	R17,g_resp_time+1
    00C2E 940E 1150 CALL	mod16u
    00C30 9300 01E0 STS	me_resp_time+1,R16
(0795)         EEPROM_Write_Bytes(RESP_TIME_ADDR, &me_resp_time.highByte, 2);
    00C32 E082      LDI	R24,2
    00C33 E090      LDI	R25,0
    00C34 8399      STD	Y+1,R25
    00C35 8388      ST	Y,R24
    00C36 ED2F      LDI	R18,0xDF
    00C37 E031      LDI	R19,1
    00C38 E400      LDI	R16,0x40
    00C39 E010      LDI	R17,0
    00C3A 940E 0E0D CALL	_EEPROM_Write_Bytes
(0796) 		
(0797)         me_hv_value.highByte = g_hv_value/100;
    00C3C E624      LDI	R18,0x64
    00C3D E030      LDI	R19,0
    00C3E 9100 031C LDS	R16,g_hv_value
    00C40 9110 031D LDS	R17,g_hv_value+1
    00C42 940E 1152 CALL	div16u
    00C44 9300 01E1 STS	me_hv_value,R16
(0798)         me_hv_value.lowByte = g_hv_value%100;
    00C46 E624      LDI	R18,0x64
    00C47 E030      LDI	R19,0
    00C48 9100 031C LDS	R16,g_hv_value
    00C4A 9110 031D LDS	R17,g_hv_value+1
    00C4C 940E 1150 CALL	mod16u
    00C4E 9300 01E2 STS	me_hv_value+1,R16
(0799)         EEPROM_Write_Bytes(HV_800V_ADDR, &me_hv_value.highByte, 2);
    00C50 E082      LDI	R24,2
    00C51 E090      LDI	R25,0
    00C52 8399      STD	Y+1,R25
    00C53 8388      ST	Y,R24
    00C54 EE21      LDI	R18,0xE1
    00C55 E031      LDI	R19,1
    00C56 E600      LDI	R16,0x60
    00C57 E010      LDI	R17,0
    00C58 940E 0E0D CALL	_EEPROM_Write_Bytes
(0800) 		
(0801) 		me_addr_code.highByte = g_addr_code/100;
    00C5A E624      LDI	R18,0x64
    00C5B E030      LDI	R19,0
    00C5C 9100 0328 LDS	R16,g_addr_code
    00C5E 9110 0329 LDS	R17,g_addr_code+1
    00C60 940E 1152 CALL	div16u
    00C62 9300 01D5 STS	me_addr_code,R16
(0802)         me_addr_code.lowByte = g_addr_code%100;
    00C64 E624      LDI	R18,0x64
    00C65 E030      LDI	R19,0
    00C66 9100 0328 LDS	R16,g_addr_code
    00C68 9110 0329 LDS	R17,g_addr_code+1
    00C6A 940E 1150 CALL	mod16u
    00C6C 9300 01D6 STS	me_addr_code+1,R16
(0803)         EEPROM_Write_Bytes(ADDR_CODE_ADDR, &me_addr_code.highByte, 2);
    00C6E E082      LDI	R24,2
    00C6F E090      LDI	R25,0
    00C70 8399      STD	Y+1,R25
    00C71 8388      ST	Y,R24
    00C72 ED25      LDI	R18,0xD5
    00C73 E031      LDI	R19,1
    00C74 E100      LDI	R16,0x10
    00C75 E010      LDI	R17,0
    00C76 940E 0E0D CALL	_EEPROM_Write_Bytes
(0804)         LedLight(LED_D1, ON);
    00C78 E021      LDI	R18,1
    00C79 E001      LDI	R16,1
    00C7A 940E 0D37 CALL	_LedLight
(0805)         LedLight(LED_D2, ON);
    00C7C E021      LDI	R18,1
    00C7D E002      LDI	R16,2
    00C7E 940E 0D37 CALL	_LedLight
(0806) 	    serv_state = SERV_STATE_MIN;
    00C80 2422      CLR	R2
    00C81 9220 0183 STS	serv_prevState+17,R2
(0807)       }
(0808)       break;
(0809) 
(0810)     default:
(0811)       break;
    00C83 9622      ADIW	R28,2
    00C84 940C 122C JMP	pop_xgsetF000
(0812)   }  
(0813) }
(0814) 
(0815) void Con_Monitor(void)
(0816) {
(0817)   if(FG_IO_IN() == HIGH)
_Con_Monitor:
    00C86 B389      IN	R24,0x19
    00C87 2799      CLR	R25
    00C88 7180      ANDI	R24,0x10
    00C89 7090      ANDI	R25,0
    00C8A 9595      ASR	R25
    00C8B 9587      ROR	R24
    00C8C 9595      ASR	R25
    00C8D 9587      ROR	R24
    00C8E 9595      ASR	R25
    00C8F 9587      ROR	R24
    00C90 9595      ASR	R25
    00C91 9587      ROR	R24
    00C92 3081      CPI	R24,1
    00C93 E0E0      LDI	R30,0
    00C94 079E      CPC	R25,R30
    00C95 F429      BNE	0x0C9B
(0818)   {
(0819)     LedBlink(LED_D1, BLINK_1HZ);
    00C96 E021      LDI	R18,1
    00C97 E001      LDI	R16,1
    00C98 940E 0D49 CALL	_LedBlink
(0820)   }  
    00C9A C004      RJMP	0x0C9F
(0821)   else
(0822)   {
(0823)     LedLight(LED_D1, OFF);
    00C9B 2722      CLR	R18
    00C9C E001      LDI	R16,1
    00C9D 940E 0D37 CALL	_LedLight
(0824)   }
    00C9F 9508      RET
(0825) }
(0826)   
(0827) //burn software don't erase the EEPROM_timer0_ovf_isr:
    00CA0 922A      ST	-Y,R2
    00CA1 923A      ST	-Y,R3
    00CA2 938A      ST	-Y,R24
    00CA3 939A      ST	-Y,R25
    00CA4 93AA      ST	-Y,R26
    00CA5 93EA      ST	-Y,R30
    00CA6 B62F      IN	R2,0x3F
    00CA7 922A      ST	-Y,R2
FILE: C:\Users\junife\Documents\GitHub\LevelMeter_ICCAVR804\ICCAVR\src\interrupt.c
(0001) #include <iom16v.h>
(0002) #include <macros.h>
(0003) #include "peripheral.h"
(0004) #include "variables.h"
(0005) 
(0006) #pragma interrupt_handler timer0_ovf_isr:iv_TIM0_OVF
(0007) void timer0_ovf_isr(void)   //1ms
(0008) {
(0009)   static u8 timer_100ms_cnt = 0, timer_1000ms_cnt = 0;
(0010)   
(0011)   //TCNT0 = 0x00 /*INVALID SETTING*/; //reload counter value
(0012)   TCNT0=131; 	 //重新赋初值
    00CA8 E883      LDI	R24,0x83
    00CA9 BF82      OUT	0x32,R24
(0013)   
(0014)   timer_1ms_flag = TRUE;
    00CAA E081      LDI	R24,1
    00CAB 9380 032C STS	timer_1ms_flag,R24
(0015)   
(0016)   if(timer_100ms_cnt++ == 100)
    00CAD 9020 0185 LDS	R2,serv_prevState+19
    00CAF 2433      CLR	R3
    00CB0 2D82      MOV	R24,R2
    00CB1 5F8F      SUBI	R24,0xFF
    00CB2 9380 0185 STS	serv_prevState+19,R24
    00CB4 2D82      MOV	R24,R2
    00CB5 3684      CPI	R24,0x64
    00CB6 F5A9      BNE	0x0CEC
(0017)   {
(0018)      timer_100ms_cnt = 0;
    00CB7 2422      CLR	R2
    00CB8 9220 0185 STS	serv_prevState+19,R2
(0019) 	 timer_100ms_flag = TRUE;
    00CBA E081      LDI	R24,1
    00CBB 9380 032B STS	timer_100ms_flag,R24
(0020) 	 if(timer_1000ms_cnt++ == 10)
    00CBD 9020 0186 LDS	R2,serv_prevState+20
    00CBF 2433      CLR	R3
    00CC0 2D82      MOV	R24,R2
    00CC1 5F8F      SUBI	R24,0xFF
    00CC2 9380 0186 STS	serv_prevState+20,R24
    00CC4 2D82      MOV	R24,R2
    00CC5 308A      CPI	R24,0xA
    00CC6 F431      BNE	0x0CCD
(0021) 	 {
(0022) 	   timer_1000ms_cnt = 0;
    00CC7 2422      CLR	R2
    00CC8 9220 0186 STS	serv_prevState+20,R2
(0023) 	   timer_1000ms_flag = TRUE;
    00CCA E081      LDI	R24,1
    00CCB 9380 032A STS	timer_1000ms_flag,R24
(0024) 	 }
(0025) 	 
(0026) 	 if(timer_3s_cnt > 0)
    00CCD 9020 01CB LDS	R2,timer_3s_cnt
    00CCF 9030 01CC LDS	R3,timer_3s_cnt+1
    00CD1 2022      TST	R2
    00CD2 F411      BNE	0x0CD5
    00CD3 2033      TST	R3
    00CD4 F031      BEQ	0x0CDB
(0027) 	 {
(0028) 	   timer_3s_cnt++;
    00CD5 01C1      MOVW	R24,R2
    00CD6 9601      ADIW	R24,1
    00CD7 9390 01CC STS	timer_3s_cnt+1,R25
    00CD9 9380 01CB STS	timer_3s_cnt,R24
(0029) 	 }
(0030) 	 if(timer_3s_cnt == 30)
    00CDB 9180 01CB LDS	R24,timer_3s_cnt
    00CDD 9190 01CC LDS	R25,timer_3s_cnt+1
    00CDF 318E      CPI	R24,0x1E
    00CE0 E0E0      LDI	R30,0
    00CE1 079E      CPC	R25,R30
    00CE2 F449      BNE	0x0CEC
(0031) 	 {
(0032) 	   timer_3s_cnt = 0;
    00CE3 2422      CLR	R2
    00CE4 2433      CLR	R3
    00CE5 9230 01CC STS	timer_3s_cnt+1,R3
    00CE7 9220 01CB STS	timer_3s_cnt,R2
(0033) 	   timer_3s_flag = TRUE;
    00CE9 E081      LDI	R24,1
    00CEA 9380 01CD STS	timer_3s_flag,R24
(0034) 	 }
(0035)   }
(0036)   
(0037)   per_dly_1ms_cnt++;
    00CEC 9180 032F LDS	R24,per_dly_1ms_cnt
    00CEE 9190 0330 LDS	R25,per_dly_1ms_cnt+1
    00CF0 9601      ADIW	R24,1
    00CF1 9390 0330 STS	per_dly_1ms_cnt+1,R25
    00CF3 9380 032F STS	per_dly_1ms_cnt,R24
(0038)   
(0039)   if(per_bypass_1ms_cnt > 0)
    00CF5 9020 032D LDS	R2,per_bypass_1ms_cnt
    00CF7 9030 032E LDS	R3,per_bypass_1ms_cnt+1
    00CF9 2022      TST	R2
    00CFA F411      BNE	0x0CFD
    00CFB 2033      TST	R3
    00CFC F031      BEQ	0x0D03
(0040)   {
(0041)     per_bypass_1ms_cnt++;
    00CFD 01C1      MOVW	R24,R2
    00CFE 9601      ADIW	R24,1
    00CFF 9390 032E STS	per_bypass_1ms_cnt+1,R25
    00D01 9380 032D STS	per_bypass_1ms_cnt,R24
(0042)   }
(0043)   
(0044)   //if(led_500ms_start_flag)
(0045)   //{
(0046)     led_500ms_cnt++;
    00D03 9180 0333 LDS	R24,led_500ms_cnt
    00D05 9190 0334 LDS	R25,led_500ms_cnt+1
    00D07 9601      ADIW	R24,1
    00D08 9390 0334 STS	led_500ms_cnt+1,R25
    00D0A 9380 0333 STS	led_500ms_cnt,R24
(0047)   //}
(0048)   //else
(0049)   //{
(0050)     //led_500ms_cnt = 0;
(0051)   //}
(0052)   
(0053)   //if(led_250ms_start_flag)
(0054)   //{
(0055)     led_250ms_cnt++;
    00D0C 9180 0331 LDS	R24,led_250ms_cnt
    00D0E 9190 0332 LDS	R25,led_250ms_cnt+1
    00D10 9601      ADIW	R24,1
    00D11 9390 0332 STS	led_250ms_cnt+1,R25
    00D13 9380 0331 STS	led_250ms_cnt,R24
    00D15 9029      LD	R2,Y+
    00D16 BE2F      OUT	0x3F,R2
    00D17 91E9      LD	R30,Y+
    00D18 91A9      LD	R26,Y+
    00D19 9199      LD	R25,Y+
    00D1A 9189      LD	R24,Y+
    00D1B 9039      LD	R3,Y+
    00D1C 9029      LD	R2,Y+
    00D1D 9518      RETI
_timer1_ovf_isr:
    00D1E 922A      ST	-Y,R2
    00D1F 938A      ST	-Y,R24
    00D20 939A      ST	-Y,R25
    00D21 B62F      IN	R2,0x3F
    00D22 922A      ST	-Y,R2
(0056)   //}
(0057)   //else
(0058)   //{
(0059)     //led_250ms_cnt = 0;
(0060)   //}
(0061) }
(0062) 
(0063) 
(0064) //#pragma interrupt_handler timer1_ovf_isr:iv_TIM1_OVF
(0065) #pragma interrupt_handler timer1_ovf_isr:iv_TIM1_OVF
(0066) void timer1_ovf_isr(void)   //100ms
(0067) {
(0068)   static u8 i = 0;
(0069)   //TIMER1 has overflowed
(0070)   TCNT1H = 0xCF;   //100ms/8us = 12500, 65536-12500 = 0xCF2C
    00D23 EC8F      LDI	R24,0xCF
    00D24 BD8D      OUT	0x2D,R24
(0071)   TCNT1L = 0x2C;
    00D25 E28C      LDI	R24,0x2C
    00D26 BD8C      OUT	0x2C,R24
(0072)   
(0073)   i++;
    00D27 9180 0187 LDS	R24,serv_prevState+21
    00D29 5F8F      SUBI	R24,0xFF
    00D2A 9380 0187 STS	serv_prevState+21,R24
(0074)   if(i==10)
    00D2C 308A      CPI	R24,0xA
    00D2D F419      BNE	0x0D31
(0075)   {
(0076)      i = 0;
    00D2E 2422      CLR	R2
    00D2F 9220 0187 STS	serv_prevState+21,R2
(0077)   }
    00D31 9029      LD	R2,Y+
(0078) }
    00D32 BE2F      OUT	0x3F,R2
    00D33 9199      LD	R25,Y+
    00D34 9189      LD	R24,Y+
    00D35 9029      LD	R2,Y+
    00D36 9518      RETI
FILE: C:\Users\junife\Documents\GitHub\LevelMeter_ICCAVR804\ICCAVR\src\led.c
(0001) #include "iom16v.h"
(0002) #include <macros.h>			//包含"位"操作头文件
(0003) #include "led.h"
(0004) #include "variables.h"	
(0005) #include "segDisp.h"	
(0006) 
(0007) #define  LED_D1_ON       PORTB &= ~(1<<1)
(0008) #define  LED_D1_OFF      PORTB |= (1<<1)
(0009) 
(0010) #define  LED_D2_ON       PORTB &= ~(1<<2)
(0011) #define  LED_D2_OFF      PORTB |= (1<<2)
(0012) 
(0013) void LedLight(u8 Num, u8 Action)
(0014) {
(0015)   if(Action == ON)
_LedLight:
  Action               --> R18
  Num                  --> R16
    00D37 3021      CPI	R18,1
    00D38 F441      BNE	0x0D41
(0016)   {
(0017)     if(Num == LED_D1)
    00D39 3001      CPI	R16,1
    00D3A F411      BNE	0x0D3D
(0018)     {
(0019) 	  //PORTB |= BIT(1);
(0020) 	  LED_D1_ON;
    00D3B 98C1      CBI	0x18,1
(0021) 	}
    00D3C C00B      RJMP	0x0D48
(0022) 	else if(Num == LED_D2)
    00D3D 3002      CPI	R16,2
    00D3E F449      BNE	0x0D48
(0023) 	{
(0024) 	  //PORTB |= BIT(2);
(0025) 	  LED_D2_ON;
    00D3F 98C2      CBI	0x18,2
(0026) 	}
(0027) 	else
(0028) 	{
(0029) 	}
(0030)   }
    00D40 C007      RJMP	0x0D48
(0031)   else  //action == OFF
(0032)   {
(0033)     if(Num == LED_D1)
    00D41 3001      CPI	R16,1
    00D42 F411      BNE	0x0D45
(0034)     {
(0035) 	  //PORTB &= ~BIT(1);
(0036) 	  LED_D1_OFF;
    00D43 9AC1      SBI	0x18,1
(0037) 	  
(0038) 	}
    00D44 C003      RJMP	0x0D48
(0039) 	else if(Num == LED_D2)
    00D45 3002      CPI	R16,2
    00D46 F409      BNE	0x0D48
(0040) 	{
(0041) 	  //PORTB &= ~BIT(2);
(0042) 	  LED_D2_OFF;
    00D47 9AC2      SBI	0x18,2
(0043) 	}
(0044) 	else
(0045) 	{
(0046) 	}
(0047)   }
    00D48 9508      RET
_LedBlink:
  Freq                 --> R18
  Num                  --> R16
    00D49 934A      ST	-Y,R20
    00D4A 935A      ST	-Y,R21
(0048)   
(0049)   //led_500ms_start_flag = FALSE;
(0050)   //led_500ms_cnt = 0;
(0051)   //led_250ms_start_flag = FALSE;
(0052)   //led_250ms_cnt = 0;
(0053)   
(0054) }
(0055) 
(0056) void LedBlink(u8 Num, u8 Freq)
(0057) {
(0058)   static u8 i = 0;
(0059)   switch(Freq)
    00D4B 2F42      MOV	R20,R18
    00D4C 2755      CLR	R21
    00D4D 3041      CPI	R20,1
    00D4E E0E0      LDI	R30,0
    00D4F 075E      CPC	R21,R30
    00D50 F029      BEQ	0x0D56
    00D51 3042      CPI	R20,2
    00D52 E0E0      LDI	R30,0
    00D53 075E      CPC	R21,R30
    00D54 F0F1      BEQ	0x0D73
    00D55 C039      RJMP	0x0D8F
(0060)   {
(0061)     case BLINK_1HZ:
(0062) 	  //led_500ms_start_flag = TRUE;
(0063) 	  if(led_500ms_cnt > 500)
    00D56 EF84      LDI	R24,0xF4
    00D57 E091      LDI	R25,1
    00D58 9020 0333 LDS	R2,led_500ms_cnt
    00D5A 9030 0334 LDS	R3,led_500ms_cnt+1
    00D5C 1582      CP	R24,R2
    00D5D 0593      CPC	R25,R3
    00D5E F580      BCC	0x0D8F
(0064) 	  {
(0065) 	    led_500ms_cnt = 0;
    00D5F 2422      CLR	R2
    00D60 2433      CLR	R3
    00D61 9230 0334 STS	led_500ms_cnt+1,R3
    00D63 9220 0333 STS	led_500ms_cnt,R2
(0066) 		if(Num == LED_D1)
    00D65 3001      CPI	R16,1
    00D66 F429      BNE	0x0D6C
(0067) 		{
(0068) 		  PORTB ^= BIT(1);
    00D67 E082      LDI	R24,2
    00D68 B228      IN	R2,0x18
    00D69 2628      EOR	R2,R24
    00D6A BA28      OUT	0x18,R2
(0069) 		}
    00D6B C023      RJMP	0x0D8F
(0070) 		else if(Num == LED_D2)
    00D6C 3002      CPI	R16,2
    00D6D F509      BNE	0x0D8F
(0071) 		{
(0072) 		  PORTB ^= BIT(2);
    00D6E E084      LDI	R24,4
    00D6F B228      IN	R2,0x18
    00D70 2628      EOR	R2,R24
    00D71 BA28      OUT	0x18,R2
(0073) 		}
(0074) 		else
(0075) 		{
(0076) 		}
(0077)       }
(0078) 	  break;
    00D72 C01C      RJMP	0x0D8F
(0079) 	
(0080)     case BLINK_2HZ:
(0081) 	  //led_250ms_start_flag = TRUE;
(0082) 	  if(led_250ms_cnt > 250)
    00D73 EF8A      LDI	R24,0xFA
    00D74 E090      LDI	R25,0
    00D75 9020 0331 LDS	R2,led_250ms_cnt
    00D77 9030 0332 LDS	R3,led_250ms_cnt+1
    00D79 1582      CP	R24,R2
    00D7A 0593      CPC	R25,R3
    00D7B F498      BCC	0x0D8F
(0083) 	  {
(0084) 	    led_250ms_cnt = 0;
    00D7C 2422      CLR	R2
    00D7D 2433      CLR	R3
    00D7E 9230 0332 STS	led_250ms_cnt+1,R3
    00D80 9220 0331 STS	led_250ms_cnt,R2
(0085) 		if(Num == LED_D1)
    00D82 3001      CPI	R16,1
    00D83 F429      BNE	0x0D89
(0086) 		{
(0087) 		  PORTB ^= BIT(1);
    00D84 E082      LDI	R24,2
    00D85 B228      IN	R2,0x18
    00D86 2628      EOR	R2,R24
    00D87 BA28      OUT	0x18,R2
(0088) 		}
    00D88 C006      RJMP	0x0D8F
(0089) 		else if(Num == LED_D2)
    00D89 3002      CPI	R16,2
    00D8A F421      BNE	0x0D8F
(0090) 		{
(0091) 		  PORTB ^= BIT(2);
    00D8B E084      LDI	R24,4
    00D8C B228      IN	R2,0x18
    00D8D 2628      EOR	R2,R24
    00D8E BA28      OUT	0x18,R2
(0092) 		}
(0093) 		else
(0094) 		{
(0095) 		}
(0096)       }
(0097) 	  break;
(0098) 	  
(0099) 	default:
(0100) 	  break;
    00D8F 9159      LD	R21,Y+
(0101)   }
(0102) }
(0103) 
    00D90 9149      LD	R20,Y+
    00D91 9508      RET
FILE: C:\Users\junife\Documents\GitHub\LevelMeter_ICCAVR804\ICCAVR\src\main.c
(0001) #include <iom16v.h>
(0002) #include <macros.h>
(0003) #include "peripheral.h"
(0004) #include "variables.h"
(0005) #include "segDisp.h"
(0006) #include "led.h"
(0007) #include "button.h"
(0008) #include "memory.h"
(0009) #include "control.h"
(0010) 
(0011) 
(0012) 
(0013) void main(void)
(0014) {
(0015)   //u16 ad_val;
(0016)   //u8 ad_cnt = 0, cnt = 0;
(0017)   //u32 ad_sum = 0;
(0018)   //u8 second = 0;
(0019) 
(0020)   peripheral_init();         //初始化
_main:
    00D92 940E 0ECE CALL	_peripheral_init
(0021)   variables_init(); 
    00D94 940E 1115 CALL	_variables_init
    00D96 C040      RJMP	0x0DD7
(0022)   while(1)
(0023)   {
(0024)     if(timer_100ms_flag)
    00D97 9020 032B LDS	R2,timer_100ms_flag
    00D99 2022      TST	R2
    00D9A F031      BEQ	0x0DA1
(0025) 	{
(0026) 	  Button_Scan();
    00D9B 940E 01AE CALL	_Button_Scan
(0027) 	  timer_100ms_flag = FALSE;
    00D9D 2422      CLR	R2
    00D9E 9220 032B STS	timer_100ms_flag,R2
(0028) 	  WDR(); //kick watchdog
    00DA0 95A8      WDR
(0029) 	}
(0030) 	
(0031) 	Con_Monitor();
    00DA1 940E 0C86 CALL	_Con_Monitor
(0032) 	
(0033)     switch(module_state)
    00DA3 9140 01EB LDS	R20,module_state
    00DA5 2755      CLR	R21
    00DA6 3041      CPI	R20,1
    00DA7 E0E0      LDI	R30,0
    00DA8 075E      CPC	R21,R30
    00DA9 F0C9      BEQ	0x0DC3
    00DAA 3042      CPI	R20,2
    00DAB E0E0      LDI	R30,0
    00DAC 075E      CPC	R21,R30
    00DAD F0C1      BEQ	0x0DC6
    00DAE 3043      CPI	R20,3
    00DAF E0E0      LDI	R30,0
    00DB0 075E      CPC	R21,R30
    00DB1 F0B9      BEQ	0x0DC9
    00DB2 3044      CPI	R20,4
    00DB3 E0E0      LDI	R30,0
    00DB4 075E      CPC	R21,R30
    00DB5 F0B1      BEQ	0x0DCC
    00DB6 3045      CPI	R20,5
    00DB7 E0E0      LDI	R30,0
    00DB8 075E      CPC	R21,R30
    00DB9 F0A9      BEQ	0x0DCF
    00DBA 3046      CPI	R20,6
    00DBB E0E0      LDI	R30,0
    00DBC 075E      CPC	R21,R30
    00DBD F0A1      BEQ	0x0DD2
    00DBE 3047      CPI	R20,7
    00DBF E0E0      LDI	R30,0
    00DC0 075E      CPC	R21,R30
    00DC1 F099      BEQ	0x0DD5
    00DC2 C014      RJMP	0x0DD7
(0034) 	{
(0035) 	  case MODULE_STATE_INIT:
(0036) 	    Con_Module_Init_Proc();
    00DC3 940E 0374 CALL	_Con_Module_Init_Proc
(0037) 	    break;
    00DC5 C011      RJMP	0x0DD7
(0038) 		
(0039)       case MODULE_STATE_WORK_NORM:
(0040) 	    Con_Module_Work_Norm_Proc();
    00DC6 940E 0468 CALL	_Con_Module_Work_Norm_Proc
(0041) 	    break;
    00DC8 C00E      RJMP	0x0DD7
(0042) 		
(0043) 	  case MODULE_STATE_WORK_WARN:
(0044) 	    Con_Module_Work_Warn_Proc();
    00DC9 940E 047C CALL	_Con_Module_Work_Warn_Proc
(0045) 	    break;
    00DCB C00B      RJMP	0x0DD7
(0046) 
(0047)       case MODULE_STATE_COMMUNICATE:
(0048)         Con_Module_Communicate_Proc();
    00DCC 940E 0487 CALL	_Con_Module_Communicate_Proc
(0049) 	    break;
    00DCE C008      RJMP	0x0DD7
(0050) 
(0051)       case MODULE_STATE_SERVICE:
(0052) 	    Con_Module_Service_Proc();
    00DCF 940E 0488 CALL	_Con_Module_Service_Proc
(0053) 	    break;	
    00DD1 C005      RJMP	0x0DD7
(0054) 		
(0055) 	  case MODULE_STATE_ERROR:
(0056) 	    Con_Module_Error_Proc();
    00DD2 940E 0490 CALL	_Con_Module_Error_Proc
(0057) 	    break;	
    00DD4 C002      RJMP	0x0DD7
(0058) 	
(0059) 	  case MODULE_STATE_QUIT:
(0060) 	    Con_Module_Quit_Proc();
    00DD5 940E 0491 CALL	_Con_Module_Quit_Proc
(0061) 	    break;	
(0062) 		
(0063) 	  default:
(0064) 	    break;
(0065) 	}
(0066)   
(0067)   
(0068)   
(0069)     //Button_Scan();
(0070) 	//if(timer_100ms_flag)
(0071) 	//{
(0072) 	  //cnt++;
(0073) 	//}
(0074) 	
(0075) 	//ad_val = EEPROM_Read(0x10);
(0076)     //Seg_Number_Show(ad_val, 100);
(0077) 	
(0078) 	//LedBlink(LED_D1, BLINK_1HZ);
(0079) 	//LedBlink(LED_D2, BLINK_2HZ);
(0080)     //Seg_Number_Show(969, 100);
(0081) 	//Seg_Alpha_Show(g, o, d, 100);
(0082)     //Delay(100);       //延时
(0083)   }
    00DD7 CFBF      RJMP	0x0D97
(0084) }
(0085) 
(0086) 
_EEPROM_Write_One_Byte:
  poll                 --> R22
  Data                 --> R10
  Addr                 --> R20
    00DD9 940E 1231 CALL	push_xgsetF00C
    00DDB 2EA2      MOV	R10,R18
    00DDC 01A8      MOVW	R20,R16
FILE: C:\Users\junife\Documents\GitHub\LevelMeter_ICCAVR804\ICCAVR\src\memory.c
(0001) #include <iom16v.h>
(0002) #include <macros.h>
(0003) #include "peripheral.h"
(0004) #include "variables.h"
(0005) #include "memory.h"
(0006) 
(0007) //读EEPROM函数
(0008) void EEPROM_Write_One_Byte(u16 Addr, u8 Data)
(0009) {
(0010)   u8 poll = 0;
    00DDD 2766      CLR	R22
(0011)   if(Addr < 512)	//如果地址大于512，无效
    00DDE 3040      CPI	R20,0
    00DDF E0E2      LDI	R30,2
    00DE0 075E      CPC	R21,R30
    00DE1 F490      BCC	0x0DF4
(0012)   {
(0013)     while( (EECR&BIT(EEWE)) && (poll<100) ) 	//查询上一次EEPROM写操作是否完成
    00DE2 C002      RJMP	0x0DE5
(0014) 	{
(0015) 	  poll++;
    00DE3 9563      INC	R22
(0016) 	  asm("nop");
    00DE4 0000      NOP
(0017) 	}
    00DE5 9BE1      SBIS	0x1C,1
    00DE6 C002      RJMP	0x0DE9
    00DE7 3664      CPI	R22,0x64
    00DE8 F3D0      BCS	0x0DE3
(0018)     EEAR = Addr;			//写入地址
    00DE9 BB5F      OUT	0x1F,R21
    00DEA BB4E      OUT	0x1E,R20
(0019)     EEDR = Data;			//写入数据
    00DEB BAAD      OUT	0x1D,R10
(0020) 	CLI(); //disable all interrupts
    00DEC 94F8      BCLR	7
(0021)     EECR |= BIT(EEMWE);		//EEPROM写主机使能：准备
    00DED 9AE2      SBI	0x1C,2
(0022)     EECR |= BIT(EEWE);		//EEPROM写使能：写入
    00DEE 9AE1      SBI	0x1C,1
(0023) 	SEI(); //re-enable interrupts
    00DEF 9478      BSET	7
(0024) 	Per_Dly_Ms(50);   //must have some delay time!!!!  5ms is not ok!!!
    00DF0 E302      LDI	R16,0x32
    00DF1 E010      LDI	R17,0
    00DF2 940E 0EE5 CALL	_Per_Dly_Ms
(0025)   }
    00DF4 940C 1238 JMP	pop_xgsetF00C
_EEPROM_Read_One_Byte:
  Temp                 --> R10
  poll                 --> R20
  Addr                 --> R16
    00DF6 940E 121D CALL	push_xgset300C
(0026) }
(0027) 
(0028) //读EEPROM函数
(0029) u8 EEPROM_Read_One_Byte(u16 Addr)
(0030) {
(0031)   u8 Temp=0, poll=0;
    00DF8 24AA      CLR	R10
    00DF9 2744      CLR	R20
(0032)   if(Addr < 512)  //如果地址大于512，读取0值
    00DFA 3000      CPI	R16,0
    00DFB E0E2      LDI	R30,2
    00DFC 071E      CPC	R17,R30
    00DFD F460      BCC	0x0E0A
(0033)   {
(0034)     while( (EECR&BIT(EEWE)) && (poll++<100) );	//查询上一次EEPROM写操作是否完成
    00DFE 9BE1      SBIS	0x1C,1
    00DFF C006      RJMP	0x0E06
    00E00 2E24      MOV	R2,R20
    00E01 2433      CLR	R3
    00E02 5F4F      SUBI	R20,0xFF
    00E03 2D82      MOV	R24,R2
    00E04 3684      CPI	R24,0x64
    00E05 F3C0      BCS	0x0DFE
(0035)     EEAR = Addr;				//写入地址
    00E06 BB1F      OUT	0x1F,R17
    00E07 BB0E      OUT	0x1E,R16
(0036)     EECR |= BIT(EERE);		//EEPROM读使能：读出
    00E08 9AE0      SBI	0x1C,0
(0037)     Temp = EEDR;				//读取数据
    00E09 B2AD      IN	R10,0x1D
(0038)   }	
(0039)   return Temp;				//返回数据
    00E0A 2D0A      MOV	R16,R10
    00E0B 940C 1222 JMP	pop_xgset300C
_EEPROM_Write_Bytes:
  i                    --> R20
  size                 --> R14
  bufferIn             --> R10
  startAddr            --> R12
    00E0D 940E 1214 CALL	push_xgset30FC
    00E0F 0159      MOVW	R10,R18
    00E10 0168      MOVW	R12,R16
    00E11 84E8      LDD	R14,Y+8
    00E12 84F9      LDD	R15,Y+9
(0040) }
(0041) 
(0042) //write EEPROM函数, several bytes
(0043) void EEPROM_Write_Bytes(u16 startAddr, u8 *bufferIn, u16 size)
(0044) {
(0045)   u16 i=0;
(0046)   for(i=0; i<size; i++)
    00E13 2744      CLR	R20
    00E14 2755      CLR	R21
    00E15 C009      RJMP	0x0E1F
(0047)   {
(0048)     EEPROM_Write_One_Byte(startAddr+i, *(bufferIn++));
    00E16 01F5      MOVW	R30,R10
    00E17 9121      LD	R18,Z+
    00E18 015F      MOVW	R10,R30
    00E19 0186      MOVW	R16,R12
    00E1A 0F04      ADD	R16,R20
    00E1B 1F15      ADC	R17,R21
    00E1C DFBC      RCALL	_EEPROM_Write_One_Byte
(0049)   }
    00E1D 5F4F      SUBI	R20,0xFF
    00E1E 4F5F      SBCI	R21,0xFF
    00E1F 154E      CP	R20,R14
    00E20 055F      CPC	R21,R15
    00E21 F3A0      BCS	0x0E16
    00E22 940C 11FE JMP	pop_xgset30FC
_EEPROM_Read_Bytes:
  i                    --> R20
  poll                 --> R22
  size                 --> R10
  bufferOut            --> R18
  startAddr            --> R16
    00E24 940E 1231 CALL	push_xgsetF00C
    00E26 80AE      LDD	R10,Y+6
    00E27 80BF      LDD	R11,Y+7
(0050) }
(0051) 
(0052) //读EEPROM函数, several bytes
(0053) void EEPROM_Read_Bytes(u16 startAddr, u8 *bufferOut, u16 size)
(0054) {
(0055)   u16 i=0, poll=0;
    00E28 2744      CLR	R20
    00E29 2755      CLR	R21
    00E2A 2766      CLR	R22
    00E2B 2777      CLR	R23
    00E2C C01F      RJMP	0x0E4C
(0056)   while(i<size)
(0057)   {
(0058)     if(startAddr+i < 512)
    00E2D 01C8      MOVW	R24,R16
    00E2E 0F84      ADD	R24,R20
    00E2F 1F95      ADC	R25,R21
    00E30 3080      CPI	R24,0
    00E31 E0E2      LDI	R30,2
    00E32 079E      CPC	R25,R30
    00E33 F4D8      BCC	0x0E4F
(0059) 	{
(0060) 	  while((EECR&BIT(EEWE)) && (poll<100))	//查询上一次EEPROM写操作是否完成
    00E34 C003      RJMP	0x0E38
(0061) 	  {
(0062) 	    poll++;
    00E35 5F6F      SUBI	R22,0xFF
    00E36 4F7F      SBCI	R23,0xFF
(0063) 	    asm("nop");
    00E37 0000      NOP
(0064) 	  }
    00E38 9BE1      SBIS	0x1C,1
    00E39 C004      RJMP	0x0E3E
    00E3A 3664      CPI	R22,0x64
    00E3B E0E0      LDI	R30,0
    00E3C 077E      CPC	R23,R30
    00E3D F3B8      BCS	0x0E35
(0065)       EEAR = startAddr+i;				//写入地址
    00E3E 0118      MOVW	R2,R16
    00E3F 0E24      ADD	R2,R20
    00E40 1E35      ADC	R3,R21
    00E41 BA3F      OUT	0x1F,R3
    00E42 BA2E      OUT	0x1E,R2
(0066)       EECR |= BIT(EERE);		//EEPROM读使能：读出
    00E43 9AE0      SBI	0x1C,0
(0067) 	  *(bufferOut++) = EEDR;	//读取数据
    00E44 B22D      IN	R2,0x1D
    00E45 01F9      MOVW	R30,R18
    00E46 9221      ST	Z+,R2
    00E47 019F      MOVW	R18,R30
(0068) 	  poll = 0;
    00E48 2766      CLR	R22
    00E49 2777      CLR	R23
(0069) 	  i++;
    00E4A 5F4F      SUBI	R20,0xFF
    00E4B 4F5F      SBCI	R21,0xFF
(0070) 	}
(0071) 	else
(0072) 	{
(0073) 	  break;  //error, out of range
(0074) 	}
(0075)   }
    00E4C 154A      CP	R20,R10
(0076) }
(0077) 
(0078) 
(0079) 
(0080) //如果在步骤5 和6 之间发生了中断，写操作将失败。因为此时EEPROM 写使能操
(0081) //作将超时。如果一个操作EEPROM的中断打断了另一个EEPROM操作，EEAR 或EEDR
(0082) //寄存器可能被修改，引起EEPROM 操作失败。建议此时关闭全局中断标志I。
(0083) 
(0084) 
(0085) //(2)等待SPMCSR 中的SPMEN 位变为零
(0086) //在CPU 写Flash 存储器的时候不能对EEPROM 进行编程。在启动EEPROM 写操作之
(0087) //前软件必须检查 Flash 写操作是否已经完成。步骤(2) 仅在软件包含引导程序并允许CPU
(0088) //对Flash 进行编程时才有用。如果CPU 永远都不会写Flash，步骤(2) 可省略。
(0089) 
(0090) 
(0091) //操作EEPROM，最好关中断。另外还要记得打开BOD哦。
(0092) //置位EEWE以启动写操作。ASM 程序没问题, C 程序超过了容许时限(四个周期)。
(0093) //超容许时限(四个周期)是因为优化级最低时，把SFR当RAM操作，才超时的。优化到0级之外的其它级，就可以了。
(0094) 
(0095)   /*u16 i=0, poll=0;   //why this not ok?
(0096)   while(i<size)
(0097)   {
(0098)     if(startAddr+i < 512)
(0099) 	{
(0100) 	  while((EECR&BIT(EEWE)) && (poll++<1000));	//查询上一次EEPROM写操作是否完成
(0101) 	  EEAR = startAddr+i;			    //写入地址
(0102)       EEDR = *(bufferIn++);	    //写入数据
(0103) 	  CLI(); //disable all interrupts
(0104)       EECR |= BIT(EEMWE);		//EEPROM写主机使能：准备
(0105)       EECR |= BIT(EEWE);		//EEPROM写使能：写入
(0106) 	  SEI(); //re-enable interrupts
(0107) 	  Delay(100);
(0108) 	  poll = 0;
(0109) 	  i++;
(0110) 	}
(0111) 	else
(0112) 	{
(0113) 	  break;  //error, out of range
(0114) 	}
(0115)   }*/    00E4D 055B      CPC	R21,R11
    00E4E F2F0      BCS	0x0E2D
    00E4F 940C 1238 JMP	pop_xgsetF00C
FILE: C:\Users\junife\Documents\GitHub\LevelMeter_ICCAVR804\ICCAVR\src\peripheral.c
(0001) //ICC-AVR application builder : 2015/10/1 19:02:47
(0002) // Target : M16
(0003) // Crystal: 1.0000Mhz
(0004) 
(0005) #include <iom16v.h>
(0006) #include <macros.h>
(0007) #include "peripheral.h"
(0008) #include "variables.h"
(0009) 
(0010) void port_init(void)
(0011) {
(0012)  PORTA = 0x00;
_port_init:
    00E51 2422      CLR	R2
    00E52 BA2B      OUT	0x1B,R2
(0013)  DDRA  = 0x00;   //PA0, PA1, PA2 as ADC;  PA3,PA4,PA5 used as IO input 
    00E53 BA2A      OUT	0x1A,R2
(0014)  PORTB = 0x06;
    00E54 E086      LDI	R24,6
    00E55 BB88      OUT	0x18,R24
(0015)  DDRB  = 0xFF;   //output
    00E56 EF8F      LDI	R24,0xFF
    00E57 BB87      OUT	0x17,R24
(0016)  PORTC = 0x00;   //m103 output only, 
    00E58 BA25      OUT	0x15,R2
(0017)  DDRC  = 0xFC;   //1: output, PC0, PC1 input
    00E59 EF8C      LDI	R24,0xFC
    00E5A BB84      OUT	0x14,R24
(0018)  PORTD = 0x00;
    00E5B BA22      OUT	0x12,R2
(0019)  DDRD  = 0x30;   //PD4,PD5 out
    00E5C E380      LDI	R24,0x30
    00E5D BB81      OUT	0x11,R24
    00E5E 9508      RET
(0020) }
(0021) 
(0022) //Watchdog initialize
(0023) // prescale: 16K 
(0024) void watchdog_init(void)
(0025) {
(0026)  WDR(); //this prevents a timout on enabling
_watchdog_init:
    00E5F 95A8      WDR
(0027)  WDTCR = 0x1F; 
    00E60 E18F      LDI	R24,0x1F
    00E61 BD81      OUT	0x21,R24
(0028)  WDTCR = 0x0F; //WATCHDOG ENABLED - dont forget to issue WDRs
    00E62 E08F      LDI	R24,0xF
    00E63 BD81      OUT	0x21,R24
    00E64 9508      RET
(0029) }
(0030) 
(0031) //TIMER0 initialize - prescale:Stop
(0032) // WGM: Normal
(0033) // desired value: 1000Hz
(0034) // actual value: Out of range
(0035) void timer0_init(void)
(0036) {
(0037)   TCCR0 |= 0x03;       //普通计时模式，普通端口操作，预分频为64   f=8M/64, T=64/8M = 8us
_timer0_init:
    00E65 B783      IN	R24,0x33
    00E66 6083      ORI	R24,3
    00E67 BF83      OUT	0x33,R24
(0038)   TCNT0 = 131;		   //频率为2.5KHz	  1ms/8us = 125,   256-125=131  						 
    00E68 E883      LDI	R24,0x83
    00E69 BF82      OUT	0x32,R24
(0039)   //SREG |= BIT(7);	   //开放全局中断   later we used SEI
(0040)   TIMSK |= BIT(TOIE0); //开放TIMER0溢出中断
    00E6A B789      IN	R24,0x39
    00E6B 6081      ORI	R24,1
    00E6C BF89      OUT	0x39,R24
    00E6D 9508      RET
(0041) }
(0042) 
(0043) //TIMER1 initialize - prescale:Stop
(0044) // WGM: 0) Normal, TOP=0xFFFF
(0045) // desired value: 10Hz, 100ms
(0046) // actual value: Out of range
(0047) void timer1_init(void)
(0048) {
(0049)   TCCR1B = 0x03;   //预分频为64   f=8M/64, T=64/8M = 8us
_timer1_init:
    00E6E E083      LDI	R24,3
    00E6F BD8E      OUT	0x2E,R24
(0050)   TCNT1H = 0xCF;   //100ms/8us = 12500, 65536-12500 = 53036, 0xCF2C
    00E70 EC8F      LDI	R24,0xCF
    00E71 BD8D      OUT	0x2D,R24
(0051)   TCNT1L = 0x2C;
    00E72 E28C      LDI	R24,0x2C
    00E73 BD8C      OUT	0x2C,R24
(0052)   TIMSK |= BIT(TOIE1);  //开放TIMER1溢出中断
    00E74 B789      IN	R24,0x39
    00E75 6084      ORI	R24,4
    00E76 BF89      OUT	0x39,R24
    00E77 9508      RET
(0053) }
(0054) 
(0055) 
(0056) //UART0 initialize
(0057) // desired baud rate: 110
(0058) // actual: baud rate:110 (0.0%)
(0059) void uart0_init(void)
(0060) {
(0061)  UCSRB = 0x00; //disable while setting baud rate
_uart0_init:
    00E78 2422      CLR	R2
    00E79 B82A      OUT	0x0A,R2
(0062)  UCSRA = 0x00;
    00E7A B82B      OUT	0x0B,R2
(0063)  UCSRC = BIT(URSEL) | 0x06;
    00E7B E886      LDI	R24,0x86
    00E7C BD80      OUT	0x20,R24
(0064)  UBRRL = 0x37; //set baud rate lo
    00E7D E387      LDI	R24,0x37
    00E7E B989      OUT	0x09,R24
(0065)  UBRRH = 0x02; //set baud rate hi
    00E7F E082      LDI	R24,2
    00E80 BD80      OUT	0x20,R24
(0066)  UCSRB = 0x18;
    00E81 E188      LDI	R24,0x18
    00E82 B98A      OUT	0x0A,R24
    00E83 9508      RET
(0067) }
(0068) 
(0069) //ADC initialize
(0070) // Conversion time: 26uS
(0071) void adc_init(void)
(0072) {
(0073)  ADCSR = 0x00; //disable adc
_adc_init:
    00E84 2422      CLR	R2
    00E85 B826      OUT	0x06,R2
(0074)  ADMUX = 0x00; //select adc input 0
    00E86 B827      OUT	0x07,R2
(0075)  ACSR  = 0x80;
    00E87 E880      LDI	R24,0x80
    00E88 B988      OUT	0x08,R24
(0076)  ADCSR = 0xE1;
    00E89 EE81      LDI	R24,0xE1
    00E8A B986      OUT	0x06,R24
    00E8B 9508      RET
_adc_start:
  addata               --> R10
  poll                 --> R20
  Num                  --> R12
    00E8C 940E 124D CALL	push_xgsetF03C
    00E8E 2EC0      MOV	R12,R16
(0077) }
(0078) 
(0079) 
(0080) 
(0081) u16 adc_start(u8 Num)
(0082) {
(0083)   u16 addata = 0;
    00E8F 24AA      CLR	R10
    00E90 24BB      CLR	R11
(0084)   u16 poll = 0;
    00E91 2744      CLR	R20
    00E92 2755      CLR	R21
(0085)   //DDRA &= ~BIT(PA1); //PA1为输入状态,   0:In
(0086)   PORTA &= ~BIT(PA0); //PA0为高阻态输入
    00E93 98D8      CBI	0x1B,0
(0087)   PORTA &= ~BIT(PA1); //PA1为高阻态输入
    00E94 98D9      CBI	0x1B,1
(0088)   PORTA &= ~BIT(PA2); //PA2为高阻态输入
    00E95 98DA      CBI	0x1B,2
(0089)   ADMUX = 0x40;  //AVCC为基准电,AD1为输入通道 01000001
    00E96 E480      LDI	R24,0x40
    00E97 B987      OUT	0x07,R24
(0090)   switch(Num)
    00E98 2D6C      MOV	R22,R12
    00E99 2777      CLR	R23
    00E9A 3060      CPI	R22,0
    00E9B 0767      CPC	R22,R23
    00E9C F049      BEQ	0x0EA6
    00E9D 3061      CPI	R22,1
    00E9E E0E0      LDI	R30,0
    00E9F 077E      CPC	R23,R30
    00EA0 F041      BEQ	0x0EA9
    00EA1 3062      CPI	R22,2
    00EA2 E0E0      LDI	R30,0
    00EA3 077E      CPC	R23,R30
    00EA4 F039      BEQ	0x0EAC
    00EA5 C008      RJMP	0x0EAE
(0091)   {
(0092)     case AD0:
(0093) 	  ADMUX = 0x40;  //AD0为输入通道 00000
    00EA6 E480      LDI	R24,0x40
    00EA7 B987      OUT	0x07,R24
(0094) 	  break;
    00EA8 C005      RJMP	0x0EAE
(0095) 	  
(0096) 	case AD1:
(0097) 	  ADMUX = 0x41; //(1<< (AD1-1));  //AD1为输入通道 00001
    00EA9 E481      LDI	R24,0x41
    00EAA B987      OUT	0x07,R24
(0098) 	  break;
    00EAB C002      RJMP	0x0EAE
(0099) 	  
(0100) 	case AD2:      
(0101) 	  ADMUX = 0x42; //(1<< (AD2-1));  //AD2为输入通道 00010
    00EAC E482      LDI	R24,0x42
    00EAD B987      OUT	0x07,R24
(0102) 	  break;
(0103) 	  
(0104) 	default:
(0105) 	  break;
(0106)   }
(0107) 
(0108)   ADCSR = 0x80;         //adc enable
    00EAE E880      LDI	R24,0x80
    00EAF B986      OUT	0x06,R24
(0109)   ADCSR |= BIT(ADSC);   //start convertion
    00EB0 9A36      SBI	0x06,6
(0110)   while( !(ADCSR&(BIT(ADIF))) && (poll++<1000) );
    00EB1 9934      SBIC	0x06,4
    00EB2 C008      RJMP	0x0EBB
    00EB3 011A      MOVW	R2,R20
    00EB4 5F4F      SUBI	R20,0xFF
    00EB5 4F5F      SBCI	R21,0xFF
    00EB6 01C1      MOVW	R24,R2
    00EB7 3E88      CPI	R24,0xE8
    00EB8 E0E3      LDI	R30,3
    00EB9 079E      CPC	R25,R30
    00EBA F3B0      BCS	0x0EB1
(0111)   if(poll>=1000)
    00EBB 3E48      CPI	R20,0xE8
    00EBC E0E3      LDI	R30,3
    00EBD 075E      CPC	R21,R30
    00EBE F010      BCS	0x0EC1
(0112)   {
(0113)       poll = 0;
    00EBF 2744      CLR	R20
    00EC0 2755      CLR	R21
(0114)   }
(0115)   addata = ADCL;
    00EC1 B0A4      IN	R10,0x04
    00EC2 24BB      CLR	R11
(0116)   addata = addata+ADCH*256;
    00EC3 B125      IN	R18,0x05
    00EC4 2733      CLR	R19
    00EC5 E000      LDI	R16,0
    00EC6 E011      LDI	R17,1
    00EC7 940E 11EE CALL	empy16s
    00EC9 0EA0      ADD	R10,R16
    00ECA 1EB1      ADC	R11,R17
(0117)   return addata;
    00ECB 0185      MOVW	R16,R10
    00ECC 940C 1256 JMP	pop_xgsetF03C
(0118) }   
(0119) 
(0120) 
(0121) //call this routine to initialize all peripherals
(0122) void peripheral_init(void)
(0123) {
(0124)  //stop errant interrupts until set up
(0125)  CLI(); //disable all interrupts
_peripheral_init:
    00ECE 94F8      BCLR	7
(0126)  port_init();
    00ECF DF81      RCALL	_port_init
(0127)  watchdog_init();
    00ED0 DF8E      RCALL	_watchdog_init
(0128)  timer0_init();
    00ED1 DF93      RCALL	_timer0_init
(0129)  timer1_init();
    00ED2 DF9B      RCALL	_timer1_init
(0130)  uart0_init();
    00ED3 DFA4      RCALL	_uart0_init
(0131)  adc_init();
    00ED4 DFAF      RCALL	_adc_init
(0132) 
(0133)  MCUCR = 0x00;
    00ED5 2422      CLR	R2
    00ED6 BE25      OUT	0x35,R2
(0134)  GICR  = 0x00;
    00ED7 BE2B      OUT	0x3B,R2
(0135)  TIMSK = 0x05; //timer interrupt sources
    00ED8 E085      LDI	R24,5
    00ED9 BF89      OUT	0x39,R24
(0136)  SEI(); //re-enable interrupts
    00EDA 9478      BSET	7
    00EDB 9508      RET
(0137)  //all peripherals are now initialized
(0138) }
(0139) 
(0140) 
(0141) //延迟函数
(0142) void Delay(signed int cnt)
(0143) {
_Delay:
  cnt                  --> R16
    00EDC C002      RJMP	0x0EDF
(0144)    while(cnt>0)
(0145)    {
(0146)        cnt--;
    00EDD 5001      SUBI	R16,1
    00EDE 4010      SBCI	R17,0
(0147)    }
    00EDF 2422      CLR	R2
    00EE0 2433      CLR	R3
    00EE1 1620      CP	R2,R16
    00EE2 0631      CPC	R3,R17
    00EE3 F3CC      BLT	0x0EDD
    00EE4 9508      RET
(0148) }
(0149) 
(0150) //延迟函数
(0151) void Per_Dly_Ms(signed int msCnt)
(0152) {
(0153)    per_dly_1ms_cnt = 0;
_Per_Dly_Ms:
  msCnt                --> R16
    00EE5 2422      CLR	R2
    00EE6 2433      CLR	R3
    00EE7 9230 0330 STS	per_dly_1ms_cnt+1,R3
    00EE9 9220 032F STS	per_dly_1ms_cnt,R2
(0154)    while(per_dly_1ms_cnt < msCnt);
    00EEB 9020 032F LDS	R2,per_dly_1ms_cnt
    00EED 9030 0330 LDS	R3,per_dly_1ms_cnt+1
    00EEF 1620      CP	R2,R16
    00EF0 0631      CPC	R3,R17
    00EF1 F3C8      BCS	0x0EEB
    00EF2 9508      RET
(0155) }
(0156) 
(0157) //延迟函数
(0158) BOOL Per_Bypass_Ms(signed int msCnt)
(0159) {
(0160)    if(per_bypass_1ms_cnt == 0)
_Per_Bypass_Ms:
  msCnt                --> R16
    00EF3 9020 032D LDS	R2,per_bypass_1ms_cnt
    00EF5 9030 032E LDS	R3,per_bypass_1ms_cnt+1
    00EF7 2022      TST	R2
    00EF8 F441      BNE	0x0F01
    00EF9 2033      TST	R3
    00EFA F431      BNE	0x0F01
(0161)    {
(0162)      per_bypass_1ms_cnt++;
    00EFB 01C1      MOVW	R24,R2
    00EFC 9601      ADIW	R24,1
    00EFD 9390 032E STS	per_bypass_1ms_cnt+1,R25
    00EFF 9380 032D STS	per_bypass_1ms_cnt,R24
(0163)    }
(0164)    if(per_bypass_1ms_cnt >= msCnt)
    00F01 9020 032D LDS	R2,per_bypass_1ms_cnt
    00F03 9030 032E LDS	R3,per_bypass_1ms_cnt+1
    00F05 1620      CP	R2,R16
    00F06 0631      CPC	R3,R17
    00F07 F040      BCS	0x0F10
(0165)    {
(0166)      per_bypass_1ms_cnt = 0;
    00F08 2422      CLR	R2
    00F09 2433      CLR	R3
    00F0A 9230 032E STS	per_bypass_1ms_cnt+1,R3
    00F0C 9220 032D STS	per_bypass_1ms_cnt,R2
(0167) 	 return TRUE;
    00F0E E001      LDI	R16,1
    00F0F C001      RJMP	0x0F11
(0168)    }
(0169)    return FALSE;
    00F10 2700      CLR	R16
(0170) }_Seg_Number_Show:
  One                  --> R12
  Ten                  --> R14
  Hundred              --> R20
  Thousand             --> R22
  dlyCnt               --> R10
  Num                  --> R12
    00F12 940E 1212 CALL	push_xgsetF0FC
    00F14 0159      MOVW	R10,R18
    00F15 0168      MOVW	R12,R16
FILE: C:\Users\junife\Documents\GitHub\LevelMeter_ICCAVR804\ICCAVR\src\segDisp.c
(0001) #include <iom16v.h>
(0002) #include <macros.h>
(0003) #include "segDisp.h"
(0004) #include "variables.h"
(0005) #include "peripheral.h"
(0006) 
(0007) static void Clear_Show(void);
(0008) 
(0009) //数组声明并定义在存储数据区code
(0010) //0~9
(0011) //#pragrma data:code  
(0012) //unsigned char const Number[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x00,};  //demo 共阴
(0013) unsigned char const Number[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,};  //meter 共阳
(0014) //A~F
(0015) //#pragrma data:code
(0016) //unsigned char const Alpha[]={0x77,0x7c,0x39,0x5e,0x79,0x71,0x6f,0x5c,0x5e,0x00,};  //demo
(0017) unsigned char const Alpha[]={0x88,0x83,0xc6,0xa1,0x86,0x8e,0x90,0xa3,0xa1,0x89,0xc1,0x82,0xff,};  //meter
(0018)                             //A,  B,   C,    D,   E,   F,   g,   o,   d,   H,   U,   G, 
(0019) //number show
(0020) void Seg_Number_Show(u16 Num, s16 dlyCnt)
(0021) {
(0022)    unsigned char Thousand,Hundred,Ten,One;
(0023)    Thousand = Num%10000/1000;   
    00F16 E120      LDI	R18,0x10
    00F17 E237      LDI	R19,0x27
    00F18 0186      MOVW	R16,R12
    00F19 940E 1150 CALL	mod16u
    00F1B EE28      LDI	R18,0xE8
    00F1C E033      LDI	R19,3
    00F1D 940E 1152 CALL	div16u
    00F1F 2F60      MOV	R22,R16
(0024)    Hundred=Num%1000/100;       //取百位
    00F20 EE28      LDI	R18,0xE8
    00F21 E033      LDI	R19,3
    00F22 0186      MOVW	R16,R12
    00F23 940E 1150 CALL	mod16u
    00F25 E624      LDI	R18,0x64
    00F26 E030      LDI	R19,0
    00F27 940E 1152 CALL	div16u
    00F29 2F40      MOV	R20,R16
(0025)    Ten=Num%100/10;        //取十位
    00F2A E624      LDI	R18,0x64
    00F2B E030      LDI	R19,0
    00F2C 0186      MOVW	R16,R12
    00F2D 940E 1150 CALL	mod16u
    00F2F E02A      LDI	R18,0xA
    00F30 E030      LDI	R19,0
    00F31 940E 1152 CALL	div16u
    00F33 2EE0      MOV	R14,R16
(0026)    One=Num%10;            //取个位  
    00F34 E02A      LDI	R18,0xA
    00F35 E030      LDI	R19,0
    00F36 0186      MOVW	R16,R12
    00F37 940E 1150 CALL	mod16u
    00F39 2EC0      MOV	R12,R16
(0027)    
(0028)    //显示thousand位   
(0029)    Clear_Show();       //bit selection clear 
    00F3A D10F      RCALL	segDisp.c:Clear_Show
(0030)    
(0031)    PORTB=Number[Thousand];     //送模码
    00F3B E889      LDI	R24,0x89
    00F3C E091      LDI	R25,1
    00F3D 2FE6      MOV	R30,R22
    00F3E 27FF      CLR	R31
    00F3F 0FE8      ADD	R30,R24
    00F40 1FF9      ADC	R31,R25
    00F41 8020      LD	R2,Z
    00F42 BA28      OUT	0x18,R2
(0032)    PORTA|=BIT(PA3);    //PA3高电平
    00F43 9ADB      SBI	0x1B,3
(0033)    PORTA&=~BIT(PA3);   //PA3低电平
    00F44 98DB      CBI	0x1B,3
(0034)    
(0035)    PORTB=~BIT(0);      //送位选
    00F45 EF8E      LDI	R24,0xFE
    00F46 BB88      OUT	0x18,R24
(0036)    PORTA|=BIT(PA4);    //PA3高电平
    00F47 9ADC      SBI	0x1B,4
(0037)    PORTA&=~BIT(PA4);   //PA3低电平
    00F48 98DC      CBI	0x1B,4
(0038)    Delay(dlyCnt);         //稍微延迟 
    00F49 0185      MOVW	R16,R10
    00F4A 940E 0EDC CALL	_Delay
(0039)    
(0040)    //显示百位   
(0041)    Clear_Show();       //bit selection clear 
    00F4C D0FD      RCALL	segDisp.c:Clear_Show
(0042)    
(0043)    PORTB=Number[Hundred];     //送模码
    00F4D E889      LDI	R24,0x89
    00F4E E091      LDI	R25,1
    00F4F 2FE4      MOV	R30,R20
    00F50 27FF      CLR	R31
    00F51 0FE8      ADD	R30,R24
    00F52 1FF9      ADC	R31,R25
    00F53 8020      LD	R2,Z
    00F54 BA28      OUT	0x18,R2
(0044)    PORTA|=BIT(PA3);    //PA3高电平
    00F55 9ADB      SBI	0x1B,3
(0045)    PORTA&=~BIT(PA3);   //PA3低电平
    00F56 98DB      CBI	0x1B,3
(0046)    
(0047)    PORTB=~BIT(1);      //送位选
    00F57 EF8D      LDI	R24,0xFD
    00F58 BB88      OUT	0x18,R24
(0048)    PORTA|=BIT(PA4);    //PA3高电平
    00F59 9ADC      SBI	0x1B,4
(0049)    PORTA&=~BIT(PA4);   //PA3低电平
    00F5A 98DC      CBI	0x1B,4
(0050)    Delay(dlyCnt);         //稍微延迟 
    00F5B 0185      MOVW	R16,R10
    00F5C 940E 0EDC CALL	_Delay
(0051)    
(0052)    //显示十位
(0053)    Clear_Show();       //bit selection clear 
    00F5E D0EB      RCALL	segDisp.c:Clear_Show
(0054)    
(0055)    PORTB=Number[Ten];  //送模码
    00F5F E889      LDI	R24,0x89
    00F60 E091      LDI	R25,1
    00F61 2DEE      MOV	R30,R14
    00F62 27FF      CLR	R31
    00F63 0FE8      ADD	R30,R24
    00F64 1FF9      ADC	R31,R25
    00F65 8020      LD	R2,Z
    00F66 BA28      OUT	0x18,R2
(0056)    PORTA|=BIT(PA3);    //PA3高电平
    00F67 9ADB      SBI	0x1B,3
(0057)    PORTA&=~BIT(PA3);   //PA3低电平
    00F68 98DB      CBI	0x1B,3
(0058)    
(0059)    PORTB=~BIT(2);      //送位选
    00F69 EF8B      LDI	R24,0xFB
    00F6A BB88      OUT	0x18,R24
(0060)    PORTA|=BIT(PA4);    //PA3高电平
    00F6B 9ADC      SBI	0x1B,4
(0061)    PORTA&=~BIT(PA4);   //PA3低电平
    00F6C 98DC      CBI	0x1B,4
(0062) 
(0063)    Delay(dlyCnt);         //稍微延迟
    00F6D 0185      MOVW	R16,R10
    00F6E 940E 0EDC CALL	_Delay
(0064)    
(0065)    //显示个位
(0066)    Clear_Show();       //bit selection clear
    00F70 D0D9      RCALL	segDisp.c:Clear_Show
(0067)    
(0068)    PORTB=Number[One];  //送模码
    00F71 E889      LDI	R24,0x89
    00F72 E091      LDI	R25,1
    00F73 2DEC      MOV	R30,R12
    00F74 27FF      CLR	R31
    00F75 0FE8      ADD	R30,R24
    00F76 1FF9      ADC	R31,R25
    00F77 8020      LD	R2,Z
    00F78 BA28      OUT	0x18,R2
(0069)    PORTA|=BIT(PA3);    //PA3高电平
    00F79 9ADB      SBI	0x1B,3
(0070)    PORTA&=~BIT(PA3);   //PA3低电平
    00F7A 98DB      CBI	0x1B,3
(0071)    
(0072)    PORTB=~BIT(3);      //送位选
    00F7B EF87      LDI	R24,0xF7
    00F7C BB88      OUT	0x18,R24
(0073)    PORTA|=BIT(PA4);    //PA3高电平
    00F7D 9ADC      SBI	0x1B,4
(0074)    PORTA&=~BIT(PA4);   //PA3低电平
    00F7E 98DC      CBI	0x1B,4
(0075)    Delay(dlyCnt);        //稍微延迟  
    00F7F 0185      MOVW	R16,R10
    00F80 940E 0EDC CALL	_Delay
    00F82 940C 1207 JMP	pop_xgsetF0FC
_Seg_Deci_Show:
  One                  --> R12
  Ten                  --> R14
  Hundred              --> R20
  Thousand             --> R22
  dlyCnt               --> R10
  intNum               --> R12
    00F84 940E 1212 CALL	push_xgsetF0FC
    00F86 0159      MOVW	R10,R18
    00F87 0168      MOVW	R12,R16
(0076) }
(0077) 
(0078) //Bytes show
(0079) void Seg_Deci_Show(u16 intNum, s16 dlyCnt)
(0080) {
(0081)    unsigned char Thousand,Hundred,Ten,One;
(0082)    Thousand = (intNum>>8)%100/10;   
    00F88 E624      LDI	R18,0x64
    00F89 E030      LDI	R19,0
    00F8A 0186      MOVW	R16,R12
    00F8B 2F01      MOV	R16,R17
    00F8C 2711      CLR	R17
    00F8D 940E 1150 CALL	mod16u
    00F8F E02A      LDI	R18,0xA
    00F90 E030      LDI	R19,0
    00F91 940E 1152 CALL	div16u
    00F93 2F60      MOV	R22,R16
(0083)    Hundred = (intNum>>8)%10;          //取百位
    00F94 E02A      LDI	R18,0xA
    00F95 E030      LDI	R19,0
    00F96 0186      MOVW	R16,R12
    00F97 2F01      MOV	R16,R17
    00F98 2711      CLR	R17
    00F99 940E 1150 CALL	mod16u
    00F9B 2F40      MOV	R20,R16
(0084)    Ten = (intNum&0xFF)%100/10;        //取十位
    00F9C E624      LDI	R18,0x64
    00F9D E030      LDI	R19,0
    00F9E 0186      MOVW	R16,R12
    00F9F 7010      ANDI	R17,0
    00FA0 940E 1150 CALL	mod16u
    00FA2 E02A      LDI	R18,0xA
    00FA3 E030      LDI	R19,0
    00FA4 940E 1152 CALL	div16u
    00FA6 2EE0      MOV	R14,R16
(0085)    One = (intNum&0xFF)%10;            //取个位  
    00FA7 E02A      LDI	R18,0xA
    00FA8 E030      LDI	R19,0
    00FA9 0186      MOVW	R16,R12
    00FAA 7010      ANDI	R17,0
    00FAB 940E 1150 CALL	mod16u
    00FAD 2EC0      MOV	R12,R16
(0086)    
(0087)    //显示thousand位   
(0088)    Clear_Show();       //bit selection clear 
    00FAE D09B      RCALL	segDisp.c:Clear_Show
(0089)    
(0090)    PORTB=Number[Thousand];     //送模码
    00FAF E889      LDI	R24,0x89
    00FB0 E091      LDI	R25,1
    00FB1 2FE6      MOV	R30,R22
    00FB2 27FF      CLR	R31
    00FB3 0FE8      ADD	R30,R24
    00FB4 1FF9      ADC	R31,R25
    00FB5 8020      LD	R2,Z
    00FB6 BA28      OUT	0x18,R2
(0091)    PORTA|=BIT(PA3);    //PA3高电平
    00FB7 9ADB      SBI	0x1B,3
(0092)    PORTA&=~BIT(PA3);   //PA3低电平
    00FB8 98DB      CBI	0x1B,3
(0093)    
(0094)    PORTB=~BIT(0);      //送位选
    00FB9 EF8E      LDI	R24,0xFE
    00FBA BB88      OUT	0x18,R24
(0095)    PORTA|=BIT(PA4);    //PA3高电平
    00FBB 9ADC      SBI	0x1B,4
(0096)    PORTA&=~BIT(PA4);   //PA3低电平
    00FBC 98DC      CBI	0x1B,4
(0097)    Delay(dlyCnt);         //稍微延迟 
    00FBD 0185      MOVW	R16,R10
    00FBE 940E 0EDC CALL	_Delay
(0098)    
(0099)    //显示百位   
(0100)    Clear_Show();       //bit selection clear 
    00FC0 D089      RCALL	segDisp.c:Clear_Show
(0101)    
(0102)    PORTB=Number[Hundred];     //送模码
    00FC1 E889      LDI	R24,0x89
    00FC2 E091      LDI	R25,1
    00FC3 2FE4      MOV	R30,R20
    00FC4 27FF      CLR	R31
    00FC5 0FE8      ADD	R30,R24
    00FC6 1FF9      ADC	R31,R25
    00FC7 8020      LD	R2,Z
    00FC8 BA28      OUT	0x18,R2
(0103)    PORTA|=BIT(PA3);    //PA3高电平
    00FC9 9ADB      SBI	0x1B,3
(0104)    PORTA&=~BIT(PA3);   //PA3低电平
    00FCA 98DB      CBI	0x1B,3
(0105)    
(0106)    PORTB=~BIT(1);      //送位选
    00FCB EF8D      LDI	R24,0xFD
    00FCC BB88      OUT	0x18,R24
(0107)    PORTA|=BIT(PA4);    //PA3高电平
    00FCD 9ADC      SBI	0x1B,4
(0108)    PORTA&=~BIT(PA4);   //PA3低电平
    00FCE 98DC      CBI	0x1B,4
(0109)    Delay(dlyCnt);         //稍微延迟 
    00FCF 0185      MOVW	R16,R10
    00FD0 940E 0EDC CALL	_Delay
(0110)    
(0111)    //显示十位
(0112)    Clear_Show();       //bit selection clear 
    00FD2 D077      RCALL	segDisp.c:Clear_Show
(0113)    
(0114)    PORTB=Number[Ten];  //送模码
    00FD3 E889      LDI	R24,0x89
    00FD4 E091      LDI	R25,1
    00FD5 2DEE      MOV	R30,R14
    00FD6 27FF      CLR	R31
    00FD7 0FE8      ADD	R30,R24
    00FD8 1FF9      ADC	R31,R25
    00FD9 8020      LD	R2,Z
    00FDA BA28      OUT	0x18,R2
(0115)    PORTA|=BIT(PA3);    //PA3高电平
    00FDB 9ADB      SBI	0x1B,3
(0116)    PORTA&=~BIT(PA3);   //PA3低电平
    00FDC 98DB      CBI	0x1B,3
(0117)    
(0118)    PORTB=~BIT(2);      //送位选
    00FDD EF8B      LDI	R24,0xFB
    00FDE BB88      OUT	0x18,R24
(0119)    PORTA|=BIT(PA4);    //PA3高电平
    00FDF 9ADC      SBI	0x1B,4
(0120)    PORTA&=~BIT(PA4);   //PA3低电平
    00FE0 98DC      CBI	0x1B,4
(0121) 
(0122)    Delay(dlyCnt);         //稍微延迟
    00FE1 0185      MOVW	R16,R10
    00FE2 940E 0EDC CALL	_Delay
(0123)    
(0124)    //显示个位
(0125)    Clear_Show();       //bit selection clear
    00FE4 D065      RCALL	segDisp.c:Clear_Show
(0126)    
(0127)    PORTB=Number[One];  //送模码
    00FE5 E889      LDI	R24,0x89
    00FE6 E091      LDI	R25,1
    00FE7 2DEC      MOV	R30,R12
    00FE8 27FF      CLR	R31
    00FE9 0FE8      ADD	R30,R24
    00FEA 1FF9      ADC	R31,R25
    00FEB 8020      LD	R2,Z
    00FEC BA28      OUT	0x18,R2
(0128)    PORTA|=BIT(PA3);    //PA3高电平
    00FED 9ADB      SBI	0x1B,3
(0129)    PORTA&=~BIT(PA3);   //PA3低电平
    00FEE 98DB      CBI	0x1B,3
(0130)    
(0131)    PORTB=~BIT(3);      //送位选
    00FEF EF87      LDI	R24,0xF7
    00FF0 BB88      OUT	0x18,R24
(0132)    PORTA|=BIT(PA4);    //PA3高电平
    00FF1 9ADC      SBI	0x1B,4
(0133)    PORTA&=~BIT(PA4);   //PA3低电平
    00FF2 98DC      CBI	0x1B,4
(0134)    Delay(dlyCnt);        //稍微延迟  
    00FF3 0185      MOVW	R16,R10
    00FF4 940E 0EDC CALL	_Delay
    00FF6 940C 1207 JMP	pop_xgsetF0FC
_Seg_Alpha_Show:
  dlyCnt               --> R10
  alphabet4            --> R12
  alphabet3            --> R14
  alphabet2            --> R20
  alphabet1            --> R22
    00FF8 940E 1212 CALL	push_xgsetF0FC
    00FFA 2F42      MOV	R20,R18
    00FFB 2F60      MOV	R22,R16
    00FFC 84EA      LDD	R14,Y+10
    00FFD 84CC      LDD	R12,Y+12
    00FFE 84AE      LDD	R10,Y+14
    00FFF 84BF      LDD	R11,Y+15
(0135) }
(0136) 
(0137) 
(0138) //alpha show
(0139) //void Seg_Alpha_Show(Char alphabet1, Char alphabet2, Char alphabet3, Char alphabet4, s16 dlyCnt)
(0140) void Seg_Alpha_Show(ALPHA_ENUM alphabet1, ALPHA_ENUM alphabet2,
(0141)                     ALPHA_ENUM alphabet3, ALPHA_ENUM alphabet4, s16 dlyCnt)
(0142) {
(0143)    //unsigned char Hundred,Ten,One;
(0144)    //Hundred=Num/100;       //取百位
(0145)    //Ten=Num%100/10;        //取十位
(0146)    //One=Num%10;            //取个位
(0147)    
(0148)    //显示thousand位   
(0149)    Clear_Show();       //bit selection clear 
    01000 D049      RCALL	segDisp.c:Clear_Show
(0150)    
(0151)    PORTB=Alpha[alphabet1];     //送模码
    01001 E984      LDI	R24,0x94
    01002 E091      LDI	R25,1
    01003 2FE6      MOV	R30,R22
    01004 27FF      CLR	R31
    01005 0FE8      ADD	R30,R24
    01006 1FF9      ADC	R31,R25
    01007 8020      LD	R2,Z
    01008 BA28      OUT	0x18,R2
(0152)    PORTA|=BIT(PA3);    //PA3高电平
    01009 9ADB      SBI	0x1B,3
(0153)    PORTA&=~BIT(PA3);   //PA3低电平
    0100A 98DB      CBI	0x1B,3
(0154)    
(0155)    PORTB=~BIT(0);      //送位选
    0100B EF8E      LDI	R24,0xFE
    0100C BB88      OUT	0x18,R24
(0156)    PORTA|=BIT(PA4);    //PA3高电平
    0100D 9ADC      SBI	0x1B,4
(0157)    PORTA&=~BIT(PA4);   //PA3低电平
    0100E 98DC      CBI	0x1B,4
(0158)    Delay(dlyCnt);         //稍微延迟 
    0100F 0185      MOVW	R16,R10
    01010 940E 0EDC CALL	_Delay
(0159)    
(0160)    //显示hundred位
(0161)    Clear_Show();       //bit selection clear 
    01012 D037      RCALL	segDisp.c:Clear_Show
(0162)    
(0163)    PORTB=Alpha[alphabet2];     //送模码
    01013 E984      LDI	R24,0x94
    01014 E091      LDI	R25,1
    01015 2FE4      MOV	R30,R20
    01016 27FF      CLR	R31
    01017 0FE8      ADD	R30,R24
    01018 1FF9      ADC	R31,R25
    01019 8020      LD	R2,Z
    0101A BA28      OUT	0x18,R2
(0164)    PORTA|=BIT(PA3);    //PA3高电平
    0101B 9ADB      SBI	0x1B,3
(0165)    PORTA&=~BIT(PA3);   //PA3低电平
    0101C 98DB      CBI	0x1B,3
(0166)    
(0167)    PORTB=~BIT(1);      //送位选
    0101D EF8D      LDI	R24,0xFD
    0101E BB88      OUT	0x18,R24
(0168)    PORTA|=BIT(PA4);    //PA3高电平
    0101F 9ADC      SBI	0x1B,4
(0169)    PORTA&=~BIT(PA4);   //PA3低电平
    01020 98DC      CBI	0x1B,4
(0170)    
(0171)    Delay(dlyCnt);         //稍微延迟
    01021 0185      MOVW	R16,R10
    01022 940E 0EDC CALL	_Delay
(0172)    
(0173)    //显示ten位
(0174)    Clear_Show();       //bit selection clear 
    01024 D025      RCALL	segDisp.c:Clear_Show
(0175)    
(0176)    PORTB=Alpha[alphabet3];     //送模码
    01025 E984      LDI	R24,0x94
    01026 E091      LDI	R25,1
    01027 2DEE      MOV	R30,R14
    01028 27FF      CLR	R31
    01029 0FE8      ADD	R30,R24
    0102A 1FF9      ADC	R31,R25
    0102B 8020      LD	R2,Z
    0102C BA28      OUT	0x18,R2
(0177)    PORTA|=BIT(PA3);    //PA3高电平
    0102D 9ADB      SBI	0x1B,3
(0178)    PORTA&=~BIT(PA3);   //PA3低电平
    0102E 98DB      CBI	0x1B,3
(0179)    
(0180)    PORTB=~BIT(2);      //送位选
    0102F EF8B      LDI	R24,0xFB
    01030 BB88      OUT	0x18,R24
(0181)    PORTA|=BIT(PA4);    //PA3高电平
    01031 9ADC      SBI	0x1B,4
(0182)    PORTA&=~BIT(PA4);   //PA3低电平
    01032 98DC      CBI	0x1B,4
(0183)    
(0184)    Delay(dlyCnt);        //稍微延迟  
    01033 0185      MOVW	R16,R10
    01034 940E 0EDC CALL	_Delay
(0185)    
(0186)    //显示bit位
(0187)    Clear_Show();       //bit selection clear 
    01036 D013      RCALL	segDisp.c:Clear_Show
(0188)    
(0189)    PORTB=Alpha[alphabet4];     //送模码
    01037 E984      LDI	R24,0x94
    01038 E091      LDI	R25,1
    01039 2DEC      MOV	R30,R12
    0103A 27FF      CLR	R31
    0103B 0FE8      ADD	R30,R24
    0103C 1FF9      ADC	R31,R25
    0103D 8020      LD	R2,Z
    0103E BA28      OUT	0x18,R2
(0190)    PORTA|=BIT(PA3);    //PA3高电平
    0103F 9ADB      SBI	0x1B,3
(0191)    PORTA&=~BIT(PA3);   //PA3低电平
    01040 98DB      CBI	0x1B,3
(0192)    
(0193)    PORTB=~BIT(3);      //送位选
    01041 EF87      LDI	R24,0xF7
    01042 BB88      OUT	0x18,R24
(0194)    PORTA|=BIT(PA4);    //PA3高电平
    01043 9ADC      SBI	0x1B,4
(0195)    PORTA&=~BIT(PA4);   //PA3低电平
    01044 98DC      CBI	0x1B,4
(0196)    
(0197)    Delay(dlyCnt);        //稍微延迟  
    01045 0185      MOVW	R16,R10
    01046 940E 0EDC CALL	_Delay
    01048 940C 1207 JMP	pop_xgsetF0FC
(0198) }
(0199) 
(0200) 
(0201) static void Clear_Show(void)
(0202) {
(0203)    PORTB=~BIT(7);      //送位选8, not used
segDisp.c:Clear_Show:
    0104A E78F      LDI	R24,0x7F
    0104B BB88      OUT	0x18,R24
(0204)    PORTA|=BIT(PA4);    //PA3高电平
    0104C 9ADC      SBI	0x1B,4
(0205)    PORTA&=~BIT(PA4);   //PA3低电平
    0104D 98DC      CBI	0x1B,4
(0206) }
(0207) 
_Seg_164_Number:
  num                  --> Y,+0
  j                    --> R20
  temp                 --> R10
  i                    --> R22
  mark                 --> R14
  color                --> Y,+14
  Num                  --> R12
    0104F 933A      ST	-Y,R19
    01050 932A      ST	-Y,R18
    01051 940E 1212 CALL	push_xgsetF0FC
    01053 0168      MOVW	R12,R16
    01054 9724      SBIW	R28,4
    01055 88E8      LDD	R14,Y+16
FILE: C:\Users\junife\Documents\GitHub\LevelMeter_ICCAVR804\ICCAVR\src\seg_HC164.c
(0001) #include <iom16v.h>
(0002) #include <macros.h>
(0003) #include "segDisp.h"
(0004) #include "variables.h"
(0005) #include "peripheral.h"
(0006) #include "seg_HC164.h"
(0007) 
(0008) #define  CLK_HIGH        PORTC |= (1<<7)
(0009) #define  CLK_LOW         PORTC &= ~(1<<7)
(0010) #define  DATA_HIGH       PORTC |= (1<<6)
(0011) #define  DATA_LOW        PORTC &= ~(1<<6)
(0012) 
(0013) #define  SEG_DISP_RED    PORTC &= ~(1<<5); PORTC |= (1<<4) 
(0014) #define  SEG_DISP_GREEN  PORTC &= ~(1<<4); PORTC |= (1<<5)
(0015) 
(0016) //数组声明并定义在存储数据区code
(0017) //0~9
(0018) //#pragrma data:code  
(0019) //unsigned char const Number[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x00,};  //demo 共阴
(0020) unsigned char const Number_A[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xfe,0xf7};  //meter 共阳
(0021) //A~F
(0022) //#pragrma data:code
(0023) //unsigned char const Alpha[]={0x77,0x7c,0x39,0x5e,0x79,0x71,0x6f,0x5c,0x5e,0x00,};  //demo
(0024) unsigned char const Alpha_A[13]={0x88,0x83,0xc6,0xa1,0x86,0x8e,0x90,0xa3,0xa1,0x89,0xc1,0x82,0xff,};  //meter
(0025) 
(0026) //number show
(0027) void Seg_164_Number(u16 Num, SEG_COLOR_ENUM color, MARK_ENUM mark)
(0028) {
(0029)    u8 num[4] = {0}; //Thousand,Hundred,Ten,One;
    01056 E584      LDI	R24,0x54
    01057 E090      LDI	R25,0
    01058 01FE      MOVW	R30,R28
    01059 E004      LDI	R16,4
    0105A E010      LDI	R17,0
    0105B 93FA      ST	-Y,R31
    0105C 93EA      ST	-Y,R30
    0105D 939A      ST	-Y,R25
    0105E 938A      ST	-Y,R24
    0105F 940E 1268 CALL	asgncblk
(0030)    u8 i=0, j=0, temp=0;   
    01061 2766      CLR	R22
    01062 2744      CLR	R20
    01063 24AA      CLR	R10
(0031)    num[0] = Num%10000/1000;     //thousand
    01064 E120      LDI	R18,0x10
    01065 E237      LDI	R19,0x27
    01066 0186      MOVW	R16,R12
    01067 940E 1150 CALL	mod16u
    01069 EE28      LDI	R18,0xE8
    0106A E033      LDI	R19,3
    0106B 940E 1152 CALL	div16u
    0106D 8308      ST	Y,R16
(0032)    num[1] = Num%1000/100;       //hundred
    0106E EE28      LDI	R18,0xE8
    0106F E033      LDI	R19,3
    01070 0186      MOVW	R16,R12
    01071 940E 1150 CALL	mod16u
    01073 E624      LDI	R18,0x64
    01074 E030      LDI	R19,0
    01075 940E 1152 CALL	div16u
    01077 8309      STD	Y+1,R16
(0033)    num[2] = Num%100/10;         //ten
    01078 E624      LDI	R18,0x64
    01079 E030      LDI	R19,0
    0107A 0186      MOVW	R16,R12
    0107B 940E 1150 CALL	mod16u
    0107D E02A      LDI	R18,0xA
    0107E E030      LDI	R19,0
    0107F 940E 1152 CALL	div16u
    01081 830A      STD	Y+2,R16
(0034)    num[3] = Num%10;             //bit
    01082 E02A      LDI	R18,0xA
    01083 E030      LDI	R19,0
    01084 0186      MOVW	R16,R12
    01085 940E 1150 CALL	mod16u
    01087 830B      STD	Y+3,R16
(0035)    
(0036)    if(num[0] == 0)
    01088 8028      LD	R2,Y
    01089 2022      TST	R2
    0108A F4B9      BNE	0x10A2
(0037)    {
(0038)      num[0] = 10;
    0108B E08A      LDI	R24,0xA
    0108C 8388      ST	Y,R24
(0039) 	 if(num[1] == 0)
    0108D 8029      LDD	R2,Y+1
    0108E 2022      TST	R2
    0108F F491      BNE	0x10A2
(0040) 	 {
(0041) 	   if(mark == MARK_HIGH)
    01090 20EE      TST	R14
    01091 F419      BNE	0x1095
(0042)        {
(0043)    	     num[1] = 11;
    01092 E08B      LDI	R24,0xB
    01093 8389      STD	Y+1,R24
(0044)        }
    01094 C008      RJMP	0x109D
(0045)        else if(mark == MARK_LOW)
    01095 2D8E      MOV	R24,R14
    01096 3081      CPI	R24,1
    01097 F419      BNE	0x109B
(0046)        {
(0047)          num[1] = 12;
    01098 E08C      LDI	R24,0xC
    01099 8389      STD	Y+1,R24
(0048)        }
    0109A C002      RJMP	0x109D
(0049)        else
(0050)        {
(0051)          num[1] = 10;
    0109B E08A      LDI	R24,0xA
    0109C 8389      STD	Y+1,R24
(0052)        }
(0053) 	   
(0054) 	   if(num[2] == 0)
    0109D 802A      LDD	R2,Y+2
    0109E 2022      TST	R2
    0109F F411      BNE	0x10A2
(0055) 	   {
(0056) 	     num[2] = 10;
    010A0 E08A      LDI	R24,0xA
    010A1 838A      STD	Y+2,R24
(0057) 	   }
(0058) 	 }
(0059)    }
(0060)    
(0061)    if(color == SEG_COLOR_RED)
    010A2 840E      LDD	R0,Y+14
    010A3 2000      TST	R0
    010A4 F419      BNE	0x10A8
(0062)    {
(0063) 	 SEG_DISP_RED;
    010A5 98AD      CBI	0x15,5
    010A6 9AAC      SBI	0x15,4
(0064)    }
    010A7 C008      RJMP	0x10B0
(0065)    else if(color == SEG_COLOR_GREEN)
    010A8 858E      LDD	R24,Y+14
    010A9 3081      CPI	R24,1
    010AA F419      BNE	0x10AE
(0066)    {
(0067) 	 SEG_DISP_GREEN;
    010AB 98AC      CBI	0x15,4
    010AC 9AAD      SBI	0x15,5
(0068)    }
    010AD C002      RJMP	0x10B0
(0069)    else
(0070)    {
(0071) 	 SEG_DISP_RED;
    010AE 98AD      CBI	0x15,5
    010AF 9AAC      SBI	0x15,4
(0072)    }
(0073) 
(0074)    for(j=0; j<4; j++)
    010B0 2744      CLR	R20
    010B1 C01A      RJMP	0x10CC
(0075)    {
(0076)      temp = Number_A[num[j]];
    010B2 01CE      MOVW	R24,R28
    010B3 2FE4      MOV	R30,R20
    010B4 27FF      CLR	R31
    010B5 0FE8      ADD	R30,R24
    010B6 1FF9      ADC	R31,R25
    010B7 81E0      LD	R30,Z
    010B8 27FF      CLR	R31
    010B9 EA81      LDI	R24,0xA1
    010BA E091      LDI	R25,1
    010BB 0FE8      ADD	R30,R24
    010BC 1FF9      ADC	R31,R25
    010BD 80A0      LD	R10,Z
(0077)      for(i=0; i<8; i++)
    010BE 2766      CLR	R22
    010BF C009      RJMP	0x10C9
(0078) 	 {
(0079) 	   CLK_LOW;
    010C0 98AF      CBI	0x15,7
(0080) 	   if(temp&0x80)  
    010C1 FEA7      SBRS	R10,7
    010C2 C002      RJMP	0x10C5
(0081) 	   {
(0082) 	     DATA_HIGH;
    010C3 9AAE      SBI	0x15,6
(0083) 	   }
    010C4 C001      RJMP	0x10C6
(0084) 	   else  
(0085) 	   {           
(0086) 	     DATA_LOW;
    010C5 98AE      CBI	0x15,6
(0087) 	   }
(0088) 	   CLK_HIGH;
    010C6 9AAF      SBI	0x15,7
(0089) 	   temp <<= 1;  //temp  = (Number_A[j] << 1);  //not same, why?
    010C7 0CAA      LSL	R10
(0090) 	 }
    010C8 9563      INC	R22
    010C9 3068      CPI	R22,0x8
    010CA F3A8      BCS	0x10C0
(0091)    }
    010CB 9543      INC	R20
    010CC 3044      CPI	R20,4
    010CD F320      BCS	0x10B2
    010CE 9624      ADIW	R28,4
    010CF 940E 1207 CALL	pop_xgsetF0FC
    010D1 9622      ADIW	R28,2
    010D2 9508      RET
_Seg_164_Alpha:
  alpha                --> Y,+0
  j                    --> R22
  temp                 --> R10
  i                    --> R12
  color                --> R20
  alphabet4            --> R10
  alphabet3            --> R12
  alphabet2            --> R14
  alphabet1            --> R22
    010D3 940E 1212 CALL	push_xgsetF0FC
    010D5 2EE2      MOV	R14,R18
    010D6 2F60      MOV	R22,R16
    010D7 9724      SBIW	R28,4
    010D8 84CE      LDD	R12,Y+14
    010D9 88A8      LDD	R10,Y+16
    010DA 894A      LDD	R20,Y+18
(0092) }
(0093) 
(0094) 
(0095) //alpha show
(0096) //void Seg_Alpha_Show(Char alphabet1, Char alphabet2, Char alphabet3, Char alphabet4, s16 dlyCnt)
(0097) void Seg_164_Alpha(ALPHA_ENUM alphabet1, ALPHA_ENUM alphabet2, ALPHA_ENUM alphabet3,
(0098)                    ALPHA_ENUM alphabet4, SEG_COLOR_ENUM color)
(0099) {
(0100)    u8 alpha[4] = {0};
    010DB E588      LDI	R24,0x58
    010DC E090      LDI	R25,0
    010DD 01FE      MOVW	R30,R28
    010DE E004      LDI	R16,4
    010DF E010      LDI	R17,0
    010E0 93FA      ST	-Y,R31
    010E1 93EA      ST	-Y,R30
    010E2 939A      ST	-Y,R25
    010E3 938A      ST	-Y,R24
    010E4 940E 1268 CALL	asgncblk
(0101)    u8 i, j, temp;
(0102)    alpha[0] = alphabet1;
    010E6 8368      ST	Y,R22
(0103)    alpha[1] = alphabet2;
    010E7 82E9      STD	Y+1,R14
(0104)    alpha[2] = alphabet3;
    010E8 82CA      STD	Y+2,R12
(0105)    alpha[3] = alphabet4;
    010E9 82AB      STD	Y+3,R10
(0106)    
(0107)    for(j=0; j<4; j++)
    010EA 2766      CLR	R22
    010EB C01B      RJMP	0x1107
(0108)    {
(0109)      temp = Alpha_A[alpha[j]];
    010EC 01CE      MOVW	R24,R28
    010ED 2FE6      MOV	R30,R22
    010EE 27FF      CLR	R31
    010EF 0FE8      ADD	R30,R24
    010F0 1FF9      ADC	R31,R25
    010F1 81E0      LD	R30,Z
    010F2 27FF      CLR	R31
    010F3 EA8E      LDI	R24,0xAE
    010F4 E091      LDI	R25,1
    010F5 0FE8      ADD	R30,R24
    010F6 1FF9      ADC	R31,R25
    010F7 80A0      LD	R10,Z
(0110)      for(i=0; i<8; i++)
    010F8 24CC      CLR	R12
    010F9 C009      RJMP	0x1103
(0111) 	 {
(0112) 	   CLK_LOW;
    010FA 98AF      CBI	0x15,7
(0113) 	   if(temp&0x80)  
    010FB FEA7      SBRS	R10,7
    010FC C002      RJMP	0x10FF
(0114) 	   {
(0115) 	     DATA_HIGH;
    010FD 9AAE      SBI	0x15,6
(0116) 	   }
    010FE C001      RJMP	0x1100
(0117) 	   else  
(0118) 	   {           
(0119) 	     DATA_LOW;
    010FF 98AE      CBI	0x15,6
(0120) 	   }
(0121) 	   CLK_HIGH;
    01100 9AAF      SBI	0x15,7
(0122) 	   temp <<= 1;
    01101 0CAA      LSL	R10
(0123) 	 }
    01102 94C3      INC	R12
    01103 2D8C      MOV	R24,R12
    01104 3088      CPI	R24,0x8
    01105 F3A0      BCS	0x10FA
(0124)    }
    01106 9563      INC	R22
    01107 3064      CPI	R22,4
    01108 F318      BCS	0x10EC
(0125)    
(0126)    if(color == SEG_COLOR_RED)
    01109 2344      TST	R20
    0110A F419      BNE	0x110E
(0127)    {
(0128)      SEG_DISP_RED;
    0110B 98AD      CBI	0x15,5
    0110C 9AAC      SBI	0x15,4
(0129)    }
    0110D C004      RJMP	0x1112
(0130)    else if(color == SEG_COLOR_GREEN)
    0110E 3041      CPI	R20,1
    0110F F411      BNE	0x1112
(0131)    {
(0132)      SEG_DISP_GREEN;
    01110 98AC      CBI	0x15,4
    01111 9AAD      SBI	0x15,5
(0133)    }
(0134)    else
(0135)    {
(0136)    }
    01112 9624      ADIW	R28,4
(0137) }
(0138) 
(0139) 
(0140) 
(0141) 
(0142) 
(0143) 
(0144) 
    01113 940C 1207 JMP	pop_xgsetF0FC
FILE: C:\Users\junife\Documents\GitHub\LevelMeter_ICCAVR804\ICCAVR\src\variables.c
(0001) #include  "variables.h"
(0002) 
(0003) //BOOL  led_500ms_start_flag;
(0004) //BOOL  led_250ms_start_flag;
(0005) u16   led_500ms_cnt;
(0006) u16   led_250ms_cnt;
(0007) u16   per_dly_1ms_cnt;
(0008) u16   per_bypass_1ms_cnt;
(0009) BOOL  timer_1ms_flag;
(0010) BOOL  timer_100ms_flag;
(0011) BOOL  timer_1000ms_flag;
(0012) u16   g_addr_code; 
(0013) u16   g_mt_full;
(0014) u16   g_mt_empty;
(0015) u16   g_per_high;
(0016) u16   g_per_low;
(0017) u16   g_resp_time;
(0018) u16   g_hv_value;
(0019) DISP_CODE_ENUM g_disp_code;
(0020) u16   g_disp_para;
(0021) u8    eeprom_buf[16] = {0};
(0022) u16	  timer_3s_cnt = 0;
(0023) BOOL  timer_3s_flag = FALSE;
(0024) BOOL  module_quit_flag = FALSE;
(0025) 
(0026) SEQ_NUM_T       me_seq_num = {15, 10, 04, 00, 00, 01};
(0027) ADDR_CODE_T     me_addr_code = {10, 00};
(0028) MT_FULL_T       me_mt_full = {06, 00};
(0029) MT_EMPTY_T      me_mt_empty = {04, 00};
(0030) 
(0031) PER_HIGH_T      me_per_high = {00, 80};
(0032) PER_LOW_T       me_per_low = {00, 20};
(0033) 
(0034) RESP_TIME_T     me_resp_time = {00, 06};
(0035) 
(0036) HV_800V_T       me_hv_value = {03, 00};
(0037) OP_TIME_T       me_op_time = {01, 00, 00, 00, 00, 00, 00, 00};
(0038) 
(0039) MODULE_STATE_ENUM  module_state = MODULE_STATE_INIT;
(0040) MODULE_STATE_ENUM  module_prevState = MODULE_STATE_INIT;
(0041) 
(0042) s16 ad_arr[150] = {0};
(0043) 
(0044) void variables_init(void)
(0045) {
(0046)   //led_500ms_start_flag = FALSE;
(0047)   //led_250ms_start_flag = FALSE;
(0048)   led_500ms_cnt = 0;
_variables_init:
    01115 2422      CLR	R2
    01116 2433      CLR	R3
    01117 9230 0334 STS	led_500ms_cnt+1,R3
    01119 9220 0333 STS	led_500ms_cnt,R2
(0049)   led_250ms_cnt = 0;
    0111B 9230 0332 STS	led_250ms_cnt+1,R3
    0111D 9220 0331 STS	led_250ms_cnt,R2
(0050)   per_dly_1ms_cnt = 0;
    0111F 9230 0330 STS	per_dly_1ms_cnt+1,R3
    01121 9220 032F STS	per_dly_1ms_cnt,R2
(0051)   per_bypass_1ms_cnt = 0;
    01123 9230 032E STS	per_bypass_1ms_cnt+1,R3
    01125 9220 032D STS	per_bypass_1ms_cnt,R2
(0052)   timer_1ms_flag = FALSE;
    01127 9220 032C STS	timer_1ms_flag,R2
(0053)   timer_100ms_flag = FALSE;
    01129 9220 032B STS	timer_100ms_flag,R2
(0054)   timer_1000ms_flag = FALSE;
    0112B 9220 032A STS	timer_1000ms_flag,R2
(0055)   g_addr_code = 0; 
    0112D 9230 0329 STS	g_addr_code+1,R3
    0112F 9220 0328 STS	g_addr_code,R2
(0056)   g_mt_full = 0;
    01131 9230 0327 STS	g_mt_full+1,R3
    01133 9220 0326 STS	g_mt_full,R2
(0057)   g_mt_empty = 0;
    01135 9230 0325 STS	g_mt_empty+1,R3
    01137 9220 0324 STS	g_mt_empty,R2
(0058)   g_per_high = 0;
    01139 9230 0323 STS	g_per_high+1,R3
    0113B 9220 0322 STS	g_per_high,R2
(0059)   g_per_low = 0;
    0113D 9230 0321 STS	g_per_low+1,R3
    0113F 9220 0320 STS	g_per_low,R2
(0060)   g_resp_time = 0;
    01141 9230 031F STS	g_resp_time+1,R3
    01143 9220 031E STS	g_resp_time,R2
(0061) 
(0062)   g_hv_value = 0;
    01145 9230 031D STS	g_hv_value+1,R3
    01147 9220 031C STS	g_hv_value,R2
(0063)   g_disp_code = DISP_CODE_MIN;
    01149 9220 0319 STS	g_disp_code,R2
(0064)   g_disp_para = 0;
    0114B 9230 031B STS	g_disp_para+1,R3
(0065) }    0114D 9220 031A STS	g_disp_para,R2
    0114F 9508      RET
mod16u:
    01150 9468      BSET	6
    01151 C001      RJMP	xdiv16u
div16u:
    01152 94E8      BCLR	6
xdiv16u:
    01153 92EA      ST	-Y,R14
    01154 92FA      ST	-Y,R15
    01155 938A      ST	-Y,R24
    01156 24EE      CLR	R14
    01157 24FF      CLR	R15
    01158 E180      LDI	R24,0x10
    01159 0F00      LSL	R16
    0115A 1F11      ROL	R17
    0115B 1CEE      ROL	R14
    0115C 1CFF      ROL	R15
    0115D 16E2      CP	R14,R18
    0115E 06F3      CPC	R15,R19
    0115F F018      BCS	0x1163
    01160 1AE2      SUB	R14,R18
    01161 0AF3      SBC	R15,R19
    01162 9503      INC	R16
    01163 958A      DEC	R24
    01164 F7A1      BNE	0x1159
    01165 F416      BRTC	0x1168
    01166 2D0E      MOV	R16,R14
    01167 2D1F      MOV	R17,R15
    01168 9189      LD	R24,Y+
    01169 90F9      LD	R15,Y+
    0116A 90E9      LD	R14,Y+
    0116B 9508      RET
div32u:
    0116C 94E8      BCLR	6
    0116D C001      RJMP	0x116F
mod32u:
    0116E 9468      BSET	6
    0116F D030      RCALL	long_div_prolog
    01170 24CC      CLR	R12
    01171 C009      RJMP	0x117B
div32s:
    01172 94E8      BCLR	6
    01173 C001      RJMP	0x1175
mod32s:
    01174 9468      BSET	6
    01175 D02A      RCALL	long_div_prolog
    01176 FD37      SBRC	R19,7
    01177 940E 125F CALL	neg32
    01179 FDB7      SBRC	R27,7
    0117A D052      RCALL	neg_R24_R27
    0117B 2477      CLR	R7
    0117C 2488      CLR	R8
    0117D 2499      CLR	R9
    0117E 24AA      CLR	R10
    0117F 24BB      CLR	R11
    01180 D042      RCALL	tst_R16_R19
    01181 F0C1      BEQ	0x119A
    01182 D045      RCALL	tst_R24_R27
    01183 F0B1      BEQ	0x119A
    01184 E2E8      LDI	R30,0x28
    01185 0F00      LSL	R16
    01186 1F11      ROL	R17
    01187 1F22      ROL	R18
    01188 1F33      ROL	R19
    01189 1C77      ROL	R7
    0118A 1C88      ROL	R8
    0118B 1C99      ROL	R9
    0118C 1CAA      ROL	R10
    0118D 1CBB      ROL	R11
    0118E 1688      CP	R8,R24
    0118F 0699      CPC	R9,R25
    01190 06AA      CPC	R10,R26
    01191 06BB      CPC	R11,R27
    01192 F028      BCS	0x1198
    01193 1A88      SUB	R8,R24
    01194 0A99      SBC	R9,R25
    01195 0AAA      SBC	R10,R26
    01196 0ABB      SBC	R11,R27
    01197 9503      INC	R16
    01198 95EA      DEC	R30
    01199 F759      BNE	0x1185
    0119A F426      BRTC	0x119F
    0119B 2D08      MOV	R16,R8
    0119C 2D19      MOV	R17,R9
    0119D 2D2A      MOV	R18,R10
    0119E 2D3B      MOV	R19,R11
    0119F C013      RJMP	long_div_epilog
long_div_prolog:
    011A0 927A      ST	-Y,R7
    011A1 928A      ST	-Y,R8
    011A2 929A      ST	-Y,R9
    011A3 92AA      ST	-Y,R10
    011A4 92BA      ST	-Y,R11
    011A5 92CA      ST	-Y,R12
    011A6 93EA      ST	-Y,R30
    011A7 938A      ST	-Y,R24
    011A8 939A      ST	-Y,R25
    011A9 93AA      ST	-Y,R26
    011AA 93BA      ST	-Y,R27
    011AB 858B      LDD	R24,Y+11
    011AC 859C      LDD	R25,Y+12
    011AD 85AD      LDD	R26,Y+13
    011AE 85BE      LDD	R27,Y+14
    011AF 2EC3      MOV	R12,R19
    011B0 F00E      BRTS	0x11B2
    011B1 26CB      EOR	R12,R27
    011B2 9508      RET
long_div_epilog:
    011B3 FCC7      SBRC	R12,7
    011B4 940E 125F CALL	neg32
    011B6 91B9      LD	R27,Y+
    011B7 91A9      LD	R26,Y+
    011B8 9199      LD	R25,Y+
    011B9 9189      LD	R24,Y+
    011BA 91E9      LD	R30,Y+
    011BB 90C9      LD	R12,Y+
    011BC 90B9      LD	R11,Y+
    011BD 90A9      LD	R10,Y+
    011BE 9099      LD	R9,Y+
    011BF 9089      LD	R8,Y+
    011C0 9079      LD	R7,Y+
    011C1 9624      ADIW	R28,4
    011C2 9508      RET
tst_R16_R19:
    011C3 2FE0      MOV	R30,R16
    011C4 2BE1      OR	R30,R17
    011C5 2BE2      OR	R30,R18
    011C6 2BE3      OR	R30,R19
    011C7 9508      RET
tst_R24_R27:
    011C8 2FE8      MOV	R30,R24
    011C9 2BE9      OR	R30,R25
    011CA 2BEA      OR	R30,R26
    011CB 2BEB      OR	R30,R27
    011CC 9508      RET
neg_R24_R27:
    011CD 9580      COM	R24
    011CE 9590      COM	R25
    011CF 95A0      COM	R26
    011D0 95B0      COM	R27
    011D1 5F8F      SUBI	R24,0xFF
    011D2 4F9F      SBCI	R25,0xFF
    011D3 4FAF      SBCI	R26,0xFF
    011D4 4FBF      SBCI	R27,0xFF
    011D5 9508      RET
mod8u:
    011D6 9468      BSET	6
    011D7 C001      RJMP	xdiv8u
div8u:
    011D8 94E8      BCLR	6
xdiv8u:
    011D9 932A      ST	-Y,R18
    011DA 92FA      ST	-Y,R15
    011DB 92EA      ST	-Y,R14
    011DC 24FF      CLR	R15
    011DD 24EE      CLR	R14
    011DE E120      LDI	R18,0x10
    011DF 0F00      LSL	R16
    011E0 1CFF      ROL	R15
    011E1 1CEE      ROL	R14
    011E2 16E1      CP	R14,R17
    011E3 F010      BCS	0x11E6
    011E4 1AE1      SUB	R14,R17
    011E5 9503      INC	R16
    011E6 952A      DEC	R18
    011E7 F7B9      BNE	0x11DF
    011E8 F40E      BRTC	0x11EA
    011E9 2D0E      MOV	R16,R14
    011EA 90E9      LD	R14,Y+
    011EB 90F9      LD	R15,Y+
    011EC 9129      LD	R18,Y+
    011ED 9508      RET
empy16s:
    011EE 920A      ST	-Y,R0
    011EF 921A      ST	-Y,R1
    011F0 938A      ST	-Y,R24
    011F1 939A      ST	-Y,R25
    011F2 9F02      MUL	R16,R18
    011F3 01C0      MOVW	R24,R0
    011F4 9F12      MUL	R17,R18
    011F5 0D90      ADD	R25,R0
    011F6 9F03      MUL	R16,R19
    011F7 0D90      ADD	R25,R0
    011F8 018C      MOVW	R16,R24
    011F9 9199      LD	R25,Y+
    011FA 9189      LD	R24,Y+
    011FB 9019      LD	R1,Y+
    011FC 9009      LD	R0,Y+
    011FD 9508      RET
pop_xgset30FC:
    011FE 90A9      LD	R10,Y+
    011FF 90B9      LD	R11,Y+
    01200 90C9      LD	R12,Y+
    01201 90D9      LD	R13,Y+
    01202 90E9      LD	R14,Y+
    01203 90F9      LD	R15,Y+
    01204 9149      LD	R20,Y+
    01205 9159      LD	R21,Y+
    01206 9508      RET
pop_xgsetF0FC:
    01207 90A9      LD	R10,Y+
    01208 90B9      LD	R11,Y+
    01209 90C9      LD	R12,Y+
    0120A 90D9      LD	R13,Y+
    0120B 90E9      LD	R14,Y+
    0120C 90F9      LD	R15,Y+
    0120D 9149      LD	R20,Y+
    0120E 9159      LD	R21,Y+
    0120F 9169      LD	R22,Y+
    01210 9179      LD	R23,Y+
    01211 9508      RET
push_xgsetF0FC:
    01212 937A      ST	-Y,R23
    01213 936A      ST	-Y,R22
push_xgset30FC:
    01214 935A      ST	-Y,R21
    01215 934A      ST	-Y,R20
push_xgset00FC:
    01216 92FA      ST	-Y,R15
    01217 92EA      ST	-Y,R14
push_xgset003C:
    01218 92DA      ST	-Y,R13
    01219 92CA      ST	-Y,R12
    0121A 92BA      ST	-Y,R11
    0121B 92AA      ST	-Y,R10
    0121C 9508      RET
push_xgset300C:
    0121D 935A      ST	-Y,R21
    0121E 934A      ST	-Y,R20
    0121F 92BA      ST	-Y,R11
    01220 92AA      ST	-Y,R10
    01221 9508      RET
pop_xgset300C:
    01222 90A9      LD	R10,Y+
    01223 90B9      LD	R11,Y+
    01224 9149      LD	R20,Y+
    01225 9159      LD	R21,Y+
    01226 9508      RET
push_xgsetF000:
    01227 937A      ST	-Y,R23
    01228 936A      ST	-Y,R22
    01229 935A      ST	-Y,R21
    0122A 934A      ST	-Y,R20
    0122B 9508      RET
pop_xgsetF000:
    0122C 9149      LD	R20,Y+
    0122D 9159      LD	R21,Y+
    0122E 9169      LD	R22,Y+
    0122F 9179      LD	R23,Y+
    01230 9508      RET
push_xgsetF00C:
    01231 937A      ST	-Y,R23
    01232 936A      ST	-Y,R22
    01233 935A      ST	-Y,R21
    01234 934A      ST	-Y,R20
    01235 92BA      ST	-Y,R11
    01236 92AA      ST	-Y,R10
    01237 9508      RET
pop_xgsetF00C:
    01238 90A9      LD	R10,Y+
    01239 90B9      LD	R11,Y+
    0123A 9149      LD	R20,Y+
    0123B 9159      LD	R21,Y+
    0123C 9169      LD	R22,Y+
    0123D 9179      LD	R23,Y+
    0123E 9508      RET
push_xgset303C:
    0123F 935A      ST	-Y,R21
    01240 934A      ST	-Y,R20
    01241 92DA      ST	-Y,R13
    01242 92CA      ST	-Y,R12
    01243 92BA      ST	-Y,R11
    01244 92AA      ST	-Y,R10
    01245 9508      RET
pop_xgset303C:
    01246 90A9      LD	R10,Y+
    01247 90B9      LD	R11,Y+
    01248 90C9      LD	R12,Y+
    01249 90D9      LD	R13,Y+
    0124A 9149      LD	R20,Y+
    0124B 9159      LD	R21,Y+
    0124C 9508      RET
push_xgsetF03C:
    0124D 937A      ST	-Y,R23
    0124E 936A      ST	-Y,R22
    0124F 935A      ST	-Y,R21
    01250 934A      ST	-Y,R20
    01251 92DA      ST	-Y,R13
    01252 92CA      ST	-Y,R12
    01253 92BA      ST	-Y,R11
    01254 92AA      ST	-Y,R10
    01255 9508      RET
pop_xgsetF03C:
    01256 90A9      LD	R10,Y+
    01257 90B9      LD	R11,Y+
    01258 90C9      LD	R12,Y+
    01259 90D9      LD	R13,Y+
    0125A 9149      LD	R20,Y+
    0125B 9159      LD	R21,Y+
    0125C 9169      LD	R22,Y+
    0125D 9179      LD	R23,Y+
    0125E 9508      RET
neg32:
    0125F 9500      COM	R16
    01260 9510      COM	R17
    01261 9520      COM	R18
    01262 9530      COM	R19
    01263 5F0F      SUBI	R16,0xFF
    01264 4F1F      SBCI	R17,0xFF
    01265 4F2F      SBCI	R18,0xFF
    01266 4F3F      SBCI	R19,0xFF
    01267 9508      RET
asgncblk:
    01268 93AA      ST	-Y,R26
    01269 93BA      ST	-Y,R27
    0126A 93EA      ST	-Y,R30
    0126B 93FA      ST	-Y,R31
    0126C 920A      ST	-Y,R0
    0126D 81AF      LDD	R26,Y+7
    0126E 85B8      LDD	R27,Y+8
    0126F 81ED      LDD	R30,Y+5
    01270 81FE      LDD	R31,Y+6
    01271 3000      CPI	R16,0
    01272 0701      CPC	R16,R17
    01273 F031      BEQ	0x127A
    01274 95C8      LPM
    01275 920D      ST	X+,R0
    01276 9631      ADIW	R30,1
    01277 5001      SUBI	R16,1
    01278 4010      SBCI	R17,0
    01279 CFF7      RJMP	0x1271
    0127A 9009      LD	R0,Y+
    0127B 91F9      LD	R31,Y+
    0127C 91E9      LD	R30,Y+
    0127D 91B9      LD	R27,Y+
    0127E 91A9      LD	R26,Y+
    0127F 9624      ADIW	R28,4
    01280 9508      RET
